diff --git a/backend/pom.xml b/backend/pom.xml
index 270307051ca3cbfb9e999340941bb6d67b059d0c..6d4d274bf6ec28bb6538b9df3cf6dee999a0a711 100644
--- a/backend/pom.xml
+++ b/backend/pom.xml
@@ -9,50 +9,54 @@
   <name>nvr-hls-backend</name>
   <properties>
     <java.version>11</java.version>
     <spring-boot.version>2.7.18</spring-boot.version>
   </properties>
   <dependencyManagement>
     <dependencies>
       <dependency>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-dependencies</artifactId>
         <version>${spring-boot.version}</version>
         <type>pom</type>
         <scope>import</scope>
       </dependency>
     </dependencies>
   </dependencyManagement>
   <dependencies>
     <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
     </dependency>
     <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-jpa</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.fasterxml.jackson.dataformat</groupId>
+      <artifactId>jackson-dataformat-yaml</artifactId>
+    </dependency>
     <dependency>
       <groupId>org.postgresql</groupId>
       <artifactId>postgresql</artifactId>
       <scope>runtime</scope>
     </dependency>
     <dependency>
       <groupId>commons-net</groupId>
       <artifactId>commons-net</artifactId>
       <version>3.9.0</version>
     </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-maven-plugin</artifactId>
         <configuration>
           <excludes>
             <exclude>
               <groupId>org.projectlombok</groupId>
               <artifactId>lombok</artifactId>
             </exclude>
           </excludes>
         </configuration>
       </plugin>
diff --git a/backend/src/main/java/com/example/nvr/risk/RiskAssessmentService.java b/backend/src/main/java/com/example/nvr/risk/RiskAssessmentService.java
index 51d2d6d9cd404bf1aa0db6212f7ba236c0555ce7..df799d27f0d1bcff152f5cb3b1ef495f85016b0a 100644
--- a/backend/src/main/java/com/example/nvr/risk/RiskAssessmentService.java
+++ b/backend/src/main/java/com/example/nvr/risk/RiskAssessmentService.java
@@ -1,1500 +1,722 @@
 package com.example.nvr.risk;
 
 import com.example.nvr.persistence.CameraAlarmEntity;
 import com.example.nvr.persistence.CameraAlarmRepository;
 import com.example.nvr.persistence.ImsiRecordEntity;
 import com.example.nvr.persistence.ImsiRecordRepository;
 import com.example.nvr.persistence.RadarTargetEntity;
 import com.example.nvr.persistence.RadarTargetRepository;
 import com.example.nvr.persistence.RiskAssessmentEntity;
 import com.example.nvr.persistence.RiskAssessmentRepository;
+import com.example.nvr.risk.config.RiskModelConfig;
+import com.example.nvr.risk.config.RiskModelConfig.ActionDefinition;
+import com.example.nvr.risk.config.RiskModelConfig.GRuleDefinition;
+import com.example.nvr.risk.config.RiskModelConfigLoader;
 import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.core.type.TypeReference;
-import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;
 
 import java.time.Duration;
 import java.time.Instant;
-import java.time.LocalDate;
-import java.time.LocalDateTime;
-import java.time.LocalTime;
-import java.time.ZoneId;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Comparator;
-import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
+import java.util.TreeSet;
 import java.util.stream.Collectors;
 
 /**
- * 风控评分与名单判定服务（v2.1）。
- *
- * <p>实现“系统架构 v2.1”中定义的 30 分钟滑窗计分、融合、白/黑名单逻辑，
- * 为风控页面提供统一的站点级风险结论。</p>
+ * 风控模型服务（P1–P4 + A1/A2/A3 重构版）。
  */
 @Service
 public class RiskAssessmentService {
 
     private static final Logger log = LoggerFactory.getLogger(RiskAssessmentService.class);
 
-    private static final Duration WINDOW = Duration.ofMinutes(30);
-    private static final Duration HISTORY_LOOKBACK = Duration.ofDays(14);
-    private static final Duration CASING_LOOKBACK = Duration.ofDays(7);
-    private static final Duration RETURN_LOOKBACK = Duration.ofDays(14);
-
-    private static final Duration BURST_MERGE = Duration.ofSeconds(90);
-    private static final Duration SESSION_BREAK = Duration.ofMinutes(15);
-    private static final Duration SESSION_LONG_GAP = Duration.ofMinutes(12);
-    private static final Duration TIME_BUCKET = Duration.ofMinutes(5);
-    private static final Duration ARRIVAL_WINDOW = Duration.ofMinutes(10);
-    private static final Duration TIGHT_WINDOW = Duration.ofMinutes(5);
-    private static final Duration ARRIVAL_HISTORY_WINDOW = ARRIVAL_WINDOW;
-    private static final int ARRIVAL_HISTORY_SAMPLES = 6;
-
-    private static final Duration CAMERA_SESSION_GAP = Duration.ofSeconds(120);
-    private static final Duration CAMERA_REENTRY_WINDOW = Duration.ofMinutes(10);
-
-    private static final Duration RADAR_TRACK_GAP = Duration.ofSeconds(20);
-    private static final Duration RADAR_INTERMITTENT_WINDOW = Duration.ofSeconds(30);
-    private static final double RADAR_NEAR_DISTANCE = 40.0;
-
-    private static final int RADAR_SCORE_CAP = 20;
-    private static final int FUSION_SCORE_CAP = 30;
-
-    private static final ZoneId DEFAULT_ZONE = ZoneId.systemDefault();
-
     private static final String SUBJECT_TYPE = "SITE";
     private static final String SUBJECT_KEY = "DEFAULT";
 
     private final RiskAssessmentRepository riskAssessmentRepository;
     private final ImsiRecordRepository imsiRecordRepository;
     private final CameraAlarmRepository cameraAlarmRepository;
     private final RadarTargetRepository radarTargetRepository;
     private final ObjectMapper objectMapper;
+    private final RiskModelConfigLoader configLoader;
 
     public RiskAssessmentService(RiskAssessmentRepository riskAssessmentRepository,
                                  ImsiRecordRepository imsiRecordRepository,
                                  CameraAlarmRepository cameraAlarmRepository,
                                  RadarTargetRepository radarTargetRepository,
-                                 ObjectMapper objectMapper) {
+                                 ObjectMapper objectMapper,
+                                 RiskModelConfigLoader configLoader) {
         this.riskAssessmentRepository = riskAssessmentRepository;
         this.imsiRecordRepository = imsiRecordRepository;
         this.cameraAlarmRepository = cameraAlarmRepository;
         this.radarTargetRepository = radarTargetRepository;
         this.objectMapper = objectMapper;
+        this.configLoader = configLoader;
     }
 
     @Transactional
     public void processImsiRecordsSaved(List<ImsiRecordEntity> records) {
         if (records == null || records.isEmpty()) {
             return;
         }
         evaluateSiteWindow(Instant.now());
     }
 
     @Transactional
     public void processCameraAlarmSaved(CameraAlarmEntity alarm) {
         if (alarm == null || alarm.getCreatedAt() == null) {
             return;
         }
         evaluateSiteWindow(Instant.now());
     }
 
     @Transactional
     public void processRadarTargetsSaved(List<RadarTargetEntity> targets) {
         if (targets == null || targets.isEmpty()) {
             return;
         }
         evaluateSiteWindow(Instant.now());
     }
 
     @Transactional(readOnly = true)
     public List<RiskAssessmentEntity> findLatestAssessments(int limit) {
         int size = Math.max(1, Math.min(limit, 200));
         List<RiskAssessmentEntity> list = riskAssessmentRepository.findTop200ByOrderByUpdatedAtDesc();
         if (list.size() <= size) {
             return list;
         }
         return list.subList(0, size);
     }
 
     @Transactional
     public void recomputeAll() {
         evaluateSiteWindow(Instant.now());
     }
 
     private void evaluateSiteWindow(Instant now) {
-        Instant windowStart = now.minus(WINDOW);
-        Instant historyStart = now.minus(HISTORY_LOOKBACK);
+        RiskModelConfig config = configLoader.getConfig();
+        RiskModelConfig.Parameters parameters = config.getParameters();
+
+        Instant windowStart = now.minus(parameters.getAnalysisWindow());
+        Instant historyStart = now.minus(parameters.getHistoryWindow());
 
         List<ImsiRecordEntity> imsiHistory = imsiRecordRepository
                 .findByFetchedAtBetweenOrderByFetchedAtAsc(historyStart, now);
         List<CameraAlarmEntity> cameraHistory = cameraAlarmRepository
                 .findByCreatedAtBetweenOrderByCreatedAtAsc(historyStart, now);
         List<RadarTargetEntity> radarHistory = radarTargetRepository
                 .findByCapturedAtBetweenOrderByCapturedAtAsc(historyStart, now);
 
         List<ImsiRecordEntity> imsiWindow = imsiHistory.stream()
                 .filter(it -> it.getFetchedAt() != null)
                 .filter(it -> !it.getFetchedAt().isBefore(windowStart) && !it.getFetchedAt().isAfter(now))
                 .collect(Collectors.toList());
         List<CameraAlarmEntity> cameraWindow = cameraHistory.stream()
                 .filter(it -> it.getCreatedAt() != null)
                 .filter(it -> !it.getCreatedAt().isBefore(windowStart) && !it.getCreatedAt().isAfter(now))
                 .collect(Collectors.toList());
         List<RadarTargetEntity> radarWindow = radarHistory.stream()
                 .filter(it -> it.getCapturedAt() != null)
                 .filter(it -> !it.getCapturedAt().isBefore(windowStart) && !it.getCapturedAt().isAfter(now))
                 .collect(Collectors.toList());
 
-        // 长窗口用于基线、重返判定。
-        RiskAssessmentEntity previous = riskAssessmentRepository
-                .findFirstBySubjectTypeAndSubjectKey(SUBJECT_TYPE, SUBJECT_KEY)
-                .orElse(null);
-
-        ScoreAccumulator score = new ScoreAccumulator();
-        Map<String, Object> metadata = new LinkedHashMap<>();
-        metadata.put("windowStart", windowStart);
-        metadata.put("windowEnd", now);
-
-        // 统一时间带判定
-        List<Instant> allInstants = new ArrayList<>();
-        imsiWindow.stream().map(ImsiRecordEntity::getFetchedAt).filter(Objects::nonNull).forEach(allInstants::add);
-        cameraWindow.stream().map(CameraAlarmEntity::getCreatedAt).filter(Objects::nonNull).forEach(allInstants::add);
-        radarWindow.stream().map(RadarTargetEntity::getCapturedAt).filter(Objects::nonNull).forEach(allInstants::add);
-        TimeBand dominantBand = determineDominantBand(allInstants);
-        if (dominantBand == TimeBand.NIGHT) {
-            score.addTimeScore("T_NIGHT", 25, "夜间活动（21:00–05:59）");
-        } else if (dominantBand == TimeBand.DUSK) {
-            score.addTimeScore("T_DUSK", 10, "黄昏活动（19:00–20:59）");
-        } else {
-            score.addTimeScore("T_DAY", 0, "白天活动（06:00–18:59）");
-        }
-        metadata.put("timeBand", dominantBand.name());
-
-        // IMSI 预处理
-        ImsiContext imsiContext = buildImsiContext(imsiHistory, windowStart, now);
-        metadata.put("imsi", imsiContext.toMetadata());
-        score.mergeImsi(imsiContext.getScoreHits());
-
-        // 摄像头
-        CameraContext cameraContext = buildCameraContext(cameraWindow);
-        metadata.put("camera", cameraContext.toMetadata());
-        score.mergeCamera(cameraContext.getScoreHits());
-
-        // 雷达
-        RadarContext radarContext = buildRadarContext(radarWindow);
-        metadata.put("radar", radarContext.toMetadata());
-        score.mergeRadar(radarContext.getScoreHits());
-
-        // 白天踩点 → 夜返标记
-        DayCasingState casingState = computeDayCasingState(imsiHistory, cameraHistory, now);
-        metadata.put("dayCasing", casingState.toMetadata());
-        if (casingState.isMarkActive() && dominantBand == TimeBand.NIGHT) {
-            score.addBaseline("CASE_BASELINE", 10, "踩点标记后夜窗基线 +10");
-        }
-        if (casingState.shouldDirectBlackOnNightReturn() && cameraContext.isEnteredAoi() && cameraContext.isNightWindow()) {
-            score.markDirectBlack("BLACK_CASING_RETURN", "白天踩点后 14 天内夜间进入 AOI");
-        }
-
-        // IMSI 夜外圈强警（3.3）
-        if (dominantBand == TimeBand.NIGHT && imsiContext.isNightOuterDwell() && !cameraContext.isEnteredAoi()) {
-            score.forceStrongAlert("STRONG_OUTER_DWELL", "夜间外圈 ≥3 桶且未入 AOI");
-        }
-
-        // 融合
-        FusionContext fusionContext = buildFusionContext(imsiContext, cameraContext, radarContext, previous, now);
-        metadata.put("fusion", fusionContext.toMetadata());
-        score.mergeFusion(fusionContext.getScoreHits());
-        if (fusionContext.isNightGroupInAoi()) {
-            score.markDirectBlack("BLACK_NIGHT_GROUP", "夜间 AOI ≥2 人");
-        }
-        if (cameraContext.isNightWindow() && cameraContext.isNightReentry()) {
-            score.markDirectBlack("BLACK_NIGHT_REENTRY", "夜间 10 分钟内进出再进 AOI");
-        }
-        if (cameraContext.isNightWindow() && cameraContext.isNightLongStay()) {
-            score.markDirectBlack("BLACK_NIGHT_LONG_STAY", "夜间 AOI 停留 ≥180s");
-        }
-
-        String classification = classify(score);
-        String summary = buildSummary(classification, score.getTotalScore(), dominantBand, score.getTopRuleDescription());
-
-        persistAssessment(now, windowStart, score, metadata, classification, summary);
-    }
-
-    private ImsiContext buildImsiContext(List<ImsiRecordEntity> history,
-                                         Instant windowStart,
-                                         Instant windowEnd) {
-        Map<String, List<ImsiRecordEntity>> grouped = history.stream()
-                .filter(Objects::nonNull)
-                .filter(rec -> rec.getFetchedAt() != null)
-                .filter(rec -> hasText(rec.getImsi()) || hasText(rec.getDeviceId()))
-                .collect(Collectors.groupingBy(this::imsiKey));
-
-        List<ImsiDeviceMetrics> metrics = new ArrayList<>();
-        Map<String, Instant> firstSeen = new HashMap<>();
-
-        for (Map.Entry<String, List<ImsiRecordEntity>> entry : grouped.entrySet()) {
-            List<ImsiRecordEntity> bursts = mergeBursts(entry.getValue());
-            if (bursts.isEmpty()) {
-                continue;
-            }
-            List<ImsiSession> sessions = buildImsiSessions(bursts);
-            ImsiDeviceMetrics deviceMetrics = new ImsiDeviceMetrics(entry.getKey(), bursts, sessions, windowStart, windowEnd);
-            metrics.add(deviceMetrics);
-            firstSeen.put(entry.getKey(), bursts.get(0).getFetchedAt());
-        }
-
-        metrics.sort(Comparator.comparingInt(ImsiDeviceMetrics::getScore).reversed());
-        ImsiDeviceMetrics top = metrics.isEmpty() ? null : metrics.get(0);
-
-        int arrivals10 = countArrivals(firstSeen, windowEnd.minus(ARRIVAL_WINDOW), windowEnd);
-        int arrivalsTight = countArrivals(firstSeen, windowEnd.minus(TIGHT_WINDOW), windowEnd);
-        List<Integer> arrivalHistory = computeArrivalHistory(firstSeen, windowEnd);
-        double arrivalZ = computeZScore(arrivals10, arrivalHistory);
-        double baselineMean = arrivalHistory.stream().mapToInt(Integer::intValue).average().orElse(0.0);
-        boolean highDetect = baselineMean >= 2.0 && arrivalHistory.size() >= 3;
-
-        List<RuleHit> hits = new ArrayList<>();
-        if (top != null) {
-            hits.addAll(top.getRuleHits());
-        }
-
-        boolean nightOuterDwell = top != null && top.isNightWindow() && top.getBucketCount() >= 3;
-
-        return new ImsiContext(metrics, top, arrivals10, arrivalsTight, arrivalZ, arrivalHistory,
-                highDetect, nightOuterDwell, hits);
-    }
-
-    private List<ImsiRecordEntity> mergeBursts(List<ImsiRecordEntity> records) {
-        List<ImsiRecordEntity> sorted = records.stream()
-                .filter(Objects::nonNull)
-                .filter(it -> it.getFetchedAt() != null)
-                .sorted(Comparator.comparing(ImsiRecordEntity::getFetchedAt))
-                .collect(Collectors.toList());
-        if (sorted.isEmpty()) {
-            return Collections.emptyList();
-        }
-        List<ImsiRecordEntity> bursts = new ArrayList<>();
-        ImsiRecordEntity last = null;
-        for (ImsiRecordEntity record : sorted) {
-            if (last == null || Duration.between(last.getFetchedAt(), record.getFetchedAt()).compareTo(BURST_MERGE) > 0) {
-                bursts.add(record);
-                last = record;
-            }
-        }
-        return bursts;
-    }
-
-    private List<ImsiSession> buildImsiSessions(List<ImsiRecordEntity> bursts) {
-        List<ImsiSession> sessions = new ArrayList<>();
-        ImsiSession current = null;
-        ImsiRecordEntity previous = null;
-        for (ImsiRecordEntity record : bursts) {
-            Instant ts = record.getFetchedAt();
-            if (ts == null) {
-                continue;
-            }
-            if (previous == null) {
-                current = new ImsiSession();
-                current.add(record);
-                sessions.add(current);
-            } else {
-                Duration gap = Duration.between(previous.getFetchedAt(), ts);
-                if (gap.compareTo(SESSION_BREAK) > 0) {
-                    current = new ImsiSession();
-                    current.add(record);
-                    sessions.add(current);
-                } else {
-                    current.add(record);
-                    if (gap.compareTo(SESSION_LONG_GAP) > 0) {
-                        current.setHasLongGapWithinSession(true);
-                    }
-                }
-            }
-            previous = record;
-        }
-        return sessions;
-    }
-
-    private CameraContext buildCameraContext(List<CameraAlarmEntity> window) {
-        List<Instant> timestamps = window.stream()
-                .map(CameraAlarmEntity::getCreatedAt)
-                .filter(Objects::nonNull)
-                .sorted()
-                .collect(Collectors.toList());
-        TimeBand band = determineDominantBand(timestamps);
-
-        List<CameraSession> sessions = buildCameraSessions(timestamps);
-
-        boolean entered = !timestamps.isEmpty();
-        boolean stayOver60 = sessions.stream().anyMatch(session -> session.getDurationSeconds() >= 60);
-        boolean stayOver180 = sessions.stream().anyMatch(session -> session.getDurationSeconds() >= 180);
-        boolean reentry = false;
-        for (int i = 1; i < sessions.size(); i++) {
-            CameraSession prev = sessions.get(i - 1);
-            CameraSession curr = sessions.get(i);
-            if (prev.getEnd() != null && curr.getStart() != null) {
-                Duration gap = Duration.between(prev.getEnd(), curr.getStart());
-                if (!gap.isNegative() && gap.compareTo(CAMERA_REENTRY_WINDOW) <= 0) {
-                    reentry = true;
-                    break;
-                }
-            }
-        }
-
-        long edgeLoopCount = window.stream()
-                .map(CameraAlarmEntity::getEventType)
-                .filter(Objects::nonNull)
-                .map(String::toLowerCase)
-                .filter(type -> type.contains("edge") || type.contains("perimeter") || type.contains("loop"))
-                .count();
-
-        boolean multiPersonHint = window.stream()
-                .map(CameraAlarmEntity::getLevel)
-                .filter(Objects::nonNull)
-                .map(String::toLowerCase)
-                .anyMatch(level -> level.contains("multi") || level.contains("group") || level.contains("crowd"));
-        if (!multiPersonHint) {
-            multiPersonHint = window.stream()
-                    .map(CameraAlarmEntity::getEventType)
-                    .filter(Objects::nonNull)
-                    .map(String::toLowerCase)
-                    .anyMatch(type -> type.contains("multi") || type.contains("group"));
-        }
-
-        List<RuleHit> hits = new ArrayList<>();
-        if (entered) {
-            if (band == TimeBand.NIGHT) {
-                hits.add(new RuleHit("C_ENTER_NIGHT", 25, "夜间进入 AOI"));
-            } else if (band == TimeBand.DUSK) {
-                hits.add(new RuleHit("C_ENTER_DUSK", 10, "黄昏进入 AOI"));
-            } else {
-                hits.add(new RuleHit("C_ENTER_DAY", 10, "白天进入 AOI"));
-            }
-        }
-        if (stayOver60) {
-            if (band == TimeBand.NIGHT) {
-                hits.add(new RuleHit("C_STAY_NIGHT", 15, "夜间 AOI 停留 >60s"));
-            } else {
-                hits.add(new RuleHit("C_STAY_DAY", 8, "白天 AOI 停留 >60s"));
-            }
-        }
-        if (stayOver180 && band == TimeBand.NIGHT) {
-            hits.add(new RuleHit("C_STAY_NIGHT_180", 10, "夜间 AOI 停留 >180s"));
-        }
-        if (reentry) {
-            if (band == TimeBand.NIGHT) {
-                hits.add(new RuleHit("C_REENTRY_NIGHT", 12, "夜间 10 分钟内进出再进"));
-            } else {
-                hits.add(new RuleHit("C_REENTRY_DAY", 6, "白天 10 分钟内进出再进"));
-            }
-        }
-        if (edgeLoopCount >= 2) {
-            if (band == TimeBand.NIGHT) {
-                hits.add(new RuleHit("C_EDGE_NIGHT", 10, "夜间 AOI 边缘绕行 ≥2 次"));
-            } else {
-                hits.add(new RuleHit("C_EDGE_DAY", 6, "白天 AOI 边缘绕行 ≥2 次"));
-            }
-        }
-
-        boolean nightWindow = band == TimeBand.NIGHT;
-
-        return new CameraContext(entered, stayOver180, reentry, multiPersonHint, nightWindow,
-                edgeLoopCount, hits, sessions, band);
-    }
-
-    private List<CameraSession> buildCameraSessions(List<Instant> timestamps) {
-        List<CameraSession> sessions = new ArrayList<>();
-        CameraSession current = null;
-        Instant previous = null;
-        for (Instant ts : timestamps) {
-            if (previous == null) {
-                current = new CameraSession(ts, ts);
-                sessions.add(current);
-            } else {
-                Duration gap = Duration.between(previous, ts);
-                if (gap.compareTo(CAMERA_SESSION_GAP) > 0) {
-                    current = new CameraSession(ts, ts);
-                    sessions.add(current);
-                } else {
-                    current.setEnd(ts);
-                }
-            }
-            previous = ts;
-        }
-        return sessions;
-    }
-
-    private RadarContext buildRadarContext(List<RadarTargetEntity> window) {
-        if (window.isEmpty()) {
-            return RadarContext.empty();
-        }
-        Map<String, List<RadarTargetEntity>> grouped = window.stream()
-                .filter(it -> it.getCapturedAt() != null)
-                .filter(it -> hasText(it.getRadarHost()) && it.getTargetId() != null)
-                .collect(Collectors.groupingBy(it -> it.getRadarHost() + "#" + it.getTargetId()));
-
-        List<RadarTrack> tracks = new ArrayList<>();
-        for (List<RadarTargetEntity> events : grouped.values()) {
-            List<RadarTargetEntity> sorted = events.stream()
-                    .sorted(Comparator.comparing(RadarTargetEntity::getCapturedAt))
-                    .collect(Collectors.toList());
-            tracks.add(new RadarTrack(sorted));
-        }
-
-        TimeBand band = determineDominantBand(window.stream()
-                .map(RadarTargetEntity::getCapturedAt)
-                .filter(Objects::nonNull)
+        Map<String, FRuleEvaluation> fEvaluations = new LinkedHashMap<>();
+        fEvaluations.put("F1", evaluateF1(cameraWindow, parameters));
+        fEvaluations.put("F2", evaluateF2(imsiWindow, imsiHistory, windowStart, parameters));
+        fEvaluations.put("F3", evaluateF3(imsiWindow, imsiHistory, windowStart, parameters));
+        fEvaluations.put("F4", evaluateF4(cameraWindow, parameters));
+
+        RiskModelConfig.PriorityDefinition priority = determinePriority(fEvaluations, config);
+        List<ActionStatus> actions = determineActions(fEvaluations, priority, config, now);
+        List<GRuleStatus> gStatuses = evaluateGRules(fEvaluations, priority, actions, imsiWindow, cameraWindow, now, config);
+        updateActionsWithDispatch(actions, gStatuses);
+
+        String state = deriveState(fEvaluations, actions, gStatuses);
+
+        Map<String, Object> details = buildDetails(config, fEvaluations, actions, gStatuses, state,
+                windowStart, now, imsiWindow, cameraWindow, radarWindow);
+        String summary = buildSummary(priority, fEvaluations, actions, gStatuses);
+
+        persistAssessment(now, windowStart, priority, details, summary);
+    }
+
+    private Map<String, Object> buildDetails(RiskModelConfig config,
+                                             Map<String, FRuleEvaluation> fEvaluations,
+                                             List<ActionStatus> actions,
+                                             List<GRuleStatus> gStatuses,
+                                             String state,
+                                             Instant windowStart,
+                                             Instant windowEnd,
+                                             List<ImsiRecordEntity> imsiWindow,
+                                             List<CameraAlarmEntity> cameraWindow,
+                                             List<RadarTargetEntity> radarWindow) {
+        Map<String, Object> details = new LinkedHashMap<>();
+        details.put("modelVersion", config.getVersion());
+        details.put("config", config.toMetadata());
+        details.put("window", Map.of(
+                "start", windowStart,
+                "end", windowEnd
+        ));
+        details.put("fRules", fEvaluations.values().stream()
+                .map(eval -> eval.toMap(config.findPriority(eval.getEscalatesTo())))
                 .collect(Collectors.toList()));
-
-        boolean anyTarget = !tracks.isEmpty();
-        boolean continuous = tracks.stream().anyMatch(track -> track.getDuration().getSeconds() >= 60);
-        boolean approachDisappear = tracks.stream().anyMatch(RadarTrack::isApproachAndDisappear);
-        boolean intermittent = tracks.stream().anyMatch(RadarTrack::isIntermittent);
-        int approachTracks = (int) tracks.stream().filter(RadarTrack::hasNearApproach).count();
-
-        boolean multiTarget = false;
-        if (tracks.size() >= 2) {
-            for (int i = 0; i < tracks.size(); i++) {
-                for (int j = i + 1; j < tracks.size(); j++) {
-                    if (tracks.get(i).overlaps(tracks.get(j))) {
-                        multiTarget = true;
-                        break;
-                    }
-                }
-                if (multiTarget) {
-                    break;
-                }
-            }
-        }
-
-        List<RuleHit> hits = new ArrayList<>();
-        if (anyTarget) {
-            hits.add(new RuleHit("R_TARGET", band == TimeBand.NIGHT ? 2 : 1, "雷达检测到目标"));
-        }
-        if (continuous) {
-            hits.add(new RuleHit("R_PERSIST", 1, "目标持续 ≥60s"));
-        }
-        if (approachDisappear) {
-            hits.add(new RuleHit("R_APPROACH", band == TimeBand.NIGHT ? 3 : 2, "逼近后消失"));
-        }
-        if (multiTarget) {
-            hits.add(new RuleHit("R_MULTI", band == TimeBand.NIGHT ? 2 : 1, "多目标同步"));
-        }
-        if (intermittent) {
-            hits.add(new RuleHit("R_INTERMITTENT", band == TimeBand.NIGHT ? 2 : 1, "间歇潜行"));
-        }
-
-        return new RadarContext(hits, approachDisappear, approachTracks, band);
-    }
-
-    private DayCasingState computeDayCasingState(List<ImsiRecordEntity> imsiHistory,
-                                                 List<CameraAlarmEntity> cameraHistory,
-                                                 Instant now) {
-        Instant casingStart = now.minus(CASING_LOOKBACK);
-        Instant returnWindowStart = now.minus(HISTORY_LOOKBACK);
-
-        Map<LocalDate, Boolean> dayBuckets = new HashMap<>();
-        Map<String, List<ImsiRecordEntity>> grouped = imsiHistory.stream()
-                .filter(it -> it.getFetchedAt() != null)
-                .filter(it -> !it.getFetchedAt().isBefore(casingStart))
-                .filter(it -> determineBand(it.getFetchedAt()) != TimeBand.NIGHT)
-                .filter(it -> hasText(it.getImsi()) || hasText(it.getDeviceId()))
-                .collect(Collectors.groupingBy(this::imsiKey));
-        for (List<ImsiRecordEntity> records : grouped.values()) {
-            List<ImsiRecordEntity> bursts = mergeBursts(records);
-            List<ImsiSession> sessions = buildImsiSessions(bursts);
-            for (ImsiSession session : sessions) {
-                if (session.getStart() == null) {
-                    continue;
-                }
-                if (session.getStart().isBefore(casingStart)) {
-                    continue;
-                }
-                if (determineBand(session.getStart()) == TimeBand.NIGHT) {
-                    continue;
-                }
-                long minutes = session.getDurationMinutes();
-                if (minutes >= 10) {
-                    LocalDate date = LocalDateTime.ofInstant(session.getStart(), DEFAULT_ZONE).toLocalDate();
-                    dayBuckets.put(date, Boolean.TRUE);
-                }
-            }
-        }
-
-        long casingDays = dayBuckets.keySet().stream()
-                .filter(date -> !date.isBefore(LocalDateTime.ofInstant(casingStart, DEFAULT_ZONE).toLocalDate()))
-                .count();
-
-        Instant latestCasing = dayBuckets.keySet().stream()
-                .map(date -> date.atStartOfDay(DEFAULT_ZONE).toInstant())
-                .max(Comparator.naturalOrder())
-                .orElse(null);
-
-        boolean markActive = latestCasing != null && Duration.between(latestCasing, now).compareTo(RETURN_LOOKBACK) <= 0;
-
-        boolean nightEntry = cameraHistory.stream()
-                .filter(it -> it.getCreatedAt() != null)
-                .filter(it -> !it.getCreatedAt().isAfter(now))
-                .filter(it -> !it.getCreatedAt().isBefore(returnWindowStart))
-                .filter(it -> determineBand(it.getCreatedAt()) == TimeBand.NIGHT)
-                .anyMatch(it -> latestCasing != null && !it.getCreatedAt().isBefore(latestCasing));
-
-        return new DayCasingState(markActive, nightEntry, latestCasing, casingDays >= 2);
-    }
-
-    private FusionContext buildFusionContext(ImsiContext imsiContext,
-                                             CameraContext cameraContext,
-                                             RadarContext radarContext,
-                                             RiskAssessmentEntity previous,
-                                             Instant now) {
-        List<RuleHit> hits = new ArrayList<>();
-
-        List<Instant> history = previous == null ? new ArrayList<>() : extractF3F4History(previous.getDetailsJson());
-        history = history.stream()
-                .filter(Objects::nonNull)
-                .filter(inst -> Duration.between(inst, now).compareTo(Duration.ofDays(7)) <= 0)
-                .collect(Collectors.toCollection(ArrayList::new));
-
-        boolean isNight = cameraContext.isNightWindow();
-        boolean f3Triggered = false;
-        boolean f4Triggered = false;
-
-        if (cameraContext.isEnteredAoi() && (imsiContext.getArrivals10() >= 2 || imsiContext.getArrivalZ() >= 2.0)) {
-            hits.add(new RuleHit("F1", isNight ? 15 : 8, "F1 协同到达"));
-        }
-        if (cameraContext.isEnteredAoi() && imsiContext.getArrivalsTight() == 0 && imsiContext.isHighDetectability()) {
-            hits.add(new RuleHit("F2", isNight ? 12 : 2, "F2 无手机嫌疑"));
-        }
-        if (isNight && cameraContext.isMultiPersonHint() && imsiContext.getArrivalsTight() >= 2) {
-            hits.add(new RuleHit("F3", 15, "F3 夜间成伙"));
-            f3Triggered = true;
-        }
-        if (isNight && imsiContext.getHighRiskDeviceCount() >= 2 && radarContext.getApproachTracks() >= 2) {
-            hits.add(new RuleHit("F4", 15, "F4 夜间多人外圈协同"));
-            f4Triggered = true;
-        }
-        if (f3Triggered || f4Triggered) {
-            history.add(now);
-        }
-        if (history.size() >= 2) {
-            hits.add(new RuleHit("F5", 6, "F5 固定搭档"));
-        }
-        if (isNight && imsiContext.getArrivalZ() >= 3.0 && radarContext.isApproachDisappear()) {
-            hits.add(new RuleHit("F6", 10, "F6 夜间异常汇聚"));
-        }
-
-        boolean nightGroup = isNight && cameraContext.isMultiPersonHint();
-
-        return new FusionContext(hits, imsiContext.getArrivals10(), imsiContext.getArrivalsTight(),
-                imsiContext.getArrivalZ(), imsiContext.isHighDetectability(), history, nightGroup);
-    }
-
-    private List<Instant> extractF3F4History(String json) {
-        if (!hasText(json)) {
-            return new ArrayList<>();
-        }
-        try {
-            JsonNode root = objectMapper.readTree(json);
-            JsonNode metadata = root.path("metadata");
-            JsonNode fusion = metadata.path("fusion");
-            JsonNode historyNode = fusion.path("f3f4History");
-            if (!historyNode.isArray()) {
-                return new ArrayList<>();
-            }
-            List<String> values = objectMapper.convertValue(historyNode, new TypeReference<List<String>>() {
-            });
-            return values.stream()
-                    .filter(Objects::nonNull)
-                    .map(this::parseInstant)
-                    .filter(Objects::nonNull)
-                    .collect(Collectors.toCollection(ArrayList::new));
-        } catch (Exception e) {
-            log.debug("Failed to parse previous fusion history", e);
-            return new ArrayList<>();
-        }
-    }
-
-    private Instant parseInstant(String value) {
-        try {
-            return Instant.parse(value);
-        } catch (Exception e) {
-            return null;
-        }
+        details.put("actions", actions.stream()
+                .map(action -> action.toMap(config.findAction(action.getId())))
+                .collect(Collectors.toList()));
+        details.put("gRules", gStatuses.stream()
+                .map(status -> status.toMap(config.getGRules().stream()
+                        .filter(def -> def.getId().equalsIgnoreCase(status.getId()))
+                        .findFirst().orElse(null)))
+                .collect(Collectors.toList()));
+        details.put("stateMachine", Map.of(
+                "current", state,
+                "definition", config.getStateMachine()
+        ));
+        details.put("observations", Map.of(
+                "imsiDevices", countDistinctImsi(imsiWindow),
+                "cameraEvents", cameraWindow.size(),
+                "radarTracks", radarWindow.size()
+        ));
+        return details;
     }
 
     private void persistAssessment(Instant now,
                                    Instant windowStart,
-                                   ScoreAccumulator score,
-                                   Map<String, Object> metadata,
-                                   String classification,
+                                   RiskModelConfig.PriorityDefinition priority,
+                                   Map<String, Object> details,
                                    String summary) {
+        String classification = priority != null ? priority.getId() : "P4";
         RiskAssessmentEntity entity = riskAssessmentRepository
                 .findFirstBySubjectTypeAndSubjectKey(SUBJECT_TYPE, SUBJECT_KEY)
                 .orElseGet(() -> new RiskAssessmentEntity(SUBJECT_TYPE, SUBJECT_KEY));
-        entity.setSubjectType(SUBJECT_TYPE);
-        entity.setSubjectKey(SUBJECT_KEY);
-        entity.setScore(score.getTotalScore());
         entity.setClassification(classification);
+        entity.setScore(null);
         entity.setSummary(summary);
         entity.setWindowStart(windowStart);
         entity.setWindowEnd(now);
         entity.setUpdatedAt(now);
-        entity.setDetailsJson(writeDetailsJson(score, metadata));
+        entity.setDetailsJson(writeDetails(details));
         riskAssessmentRepository.save(entity);
     }
 
-    private String classify(ScoreAccumulator score) {
-        if (!score.getDirectBlackRules().isEmpty()) {
-            return "BLACK";
-        }
-        if (score.getTotalScore() >= 70) {
-            return "BLACK";
-        }
-        if (score.getTotalScore() >= 55 || score.isForceStrongAlert()) {
-            return "STRONG_ALERT";
-        }
-        if (score.getTotalScore() >= 30) {
-            return "GRAY";
-        }
-        return "LOG_ONLY";
-    }
-
-    private String buildSummary(String classification,
-                                int totalScore,
-                                TimeBand band,
-                                String topRule) {
-        String label;
-        switch (classification) {
-            case "BLACK":
-                label = "黑名单";
-                break;
-            case "STRONG_ALERT":
-                label = "强警戒";
-                break;
-            case "GRAY":
-                label = "灰名单";
-                break;
-            default:
-                label = "仅记录";
-        }
-        StringBuilder sb = new StringBuilder(label)
-                .append(" | ")
-                .append(totalScore)
-                .append(" 分")
-                .append(" | ")
-                .append(band == TimeBand.NIGHT ? "夜间窗" : band == TimeBand.DUSK ? "黄昏窗" : "白天窗");
-        if (hasText(topRule)) {
-            sb.append(" | ").append(topRule);
-        }
-        return sb.toString();
-    }
-
-    private String writeDetailsJson(ScoreAccumulator score, Map<String, Object> metadata) {
-        Map<String, Object> payload = new LinkedHashMap<>();
-        payload.put("scoreHits", score.getScoreHits());
-        payload.put("directBlack", score.getDirectBlackRules());
-        payload.put("strongAlert", score.getStrongAlertRules());
-        payload.put("metadata", metadata);
+    private String writeDetails(Map<String, Object> details) {
         try {
-            return objectMapper.writeValueAsString(payload);
-        } catch (JsonProcessingException e) {
-            log.warn("Failed to serialize risk assessment details", e);
+            return objectMapper.writeValueAsString(details);
+        } catch (JsonProcessingException ex) {
+            log.warn("Failed to serialize risk assessment details", ex);
             return "{}";
         }
     }
 
-    private static TimeBand determineBand(Instant instant) {
-        if (instant == null) {
-            return TimeBand.DAY;
-        }
-        LocalTime time = LocalDateTime.ofInstant(instant, DEFAULT_ZONE).toLocalTime();
-        if (!time.isBefore(LocalTime.of(6, 0)) && !time.isAfter(LocalTime.of(18, 59))) {
-            return TimeBand.DAY;
-        }
-        if (!time.isBefore(LocalTime.of(19, 0)) && !time.isAfter(LocalTime.of(20, 59))) {
-            return TimeBand.DUSK;
-        }
-        return TimeBand.NIGHT;
-    }
-
-    private static TimeBand determineDominantBand(List<Instant> instants) {
-        if (instants == null || instants.isEmpty()) {
-            return TimeBand.DAY;
-        }
-        EnumMap<TimeBand, Long> counter = new EnumMap<>(TimeBand.class);
-        for (Instant instant : instants) {
-            TimeBand band = determineBand(instant);
-            counter.merge(band, 1L, Long::sum);
-        }
-        return counter.entrySet().stream()
-                .max(Map.Entry.comparingByValue())
-                .map(Map.Entry::getKey)
-                .orElse(TimeBand.DAY);
-    }
-
-    private int countArrivals(Map<String, Instant> firstSeen, Instant start, Instant end) {
-        if (firstSeen.isEmpty() || start == null || end == null) {
-            return 0;
-        }
-        return (int) firstSeen.values().stream()
-                .filter(Objects::nonNull)
-                .filter(ts -> !ts.isBefore(start) && !ts.isAfter(end))
+    private RiskModelConfig.PriorityDefinition determinePriority(Map<String, FRuleEvaluation> fEvaluations,
+                                                                  RiskModelConfig config) {
+        if (fEvaluations.get("F4").isTriggered()) {
+            return config.findPriority("P1");
+        }
+        if (fEvaluations.get("F3").isTriggered()) {
+            return config.findPriority("P2");
+        }
+        if (fEvaluations.get("F1").isTriggered() || fEvaluations.get("F2").isTriggered()) {
+            return config.findPriority("P3");
+        }
+        return config.findPriority("P4");
+    }
+
+    private List<ActionStatus> determineActions(Map<String, FRuleEvaluation> fEvaluations,
+                                                RiskModelConfig.PriorityDefinition priority,
+                                                RiskModelConfig config,
+                                                Instant now) {
+        List<ActionStatus> actions = new ArrayList<>();
+        boolean anyF = fEvaluations.values().stream().anyMatch(FRuleEvaluation::isTriggered);
+        actions.add(ActionStatus.recommended("A1", anyF,
+                anyF ? "触发F规则，进入监控记录" : "未触发F规则", now));
+
+        boolean needA2 = fEvaluations.get("F4").isTriggered() || fEvaluations.get("F3").isTriggered();
+        actions.add(ActionStatus.recommended("A2", needA2,
+                needA2 ? "P2及以上事件需远程挑战" : "无需远程挑战", needA2 ? now : null));
+
+        boolean suggestA3 = priority != null && ("P1".equalsIgnoreCase(priority.getId())
+                || fEvaluations.get("F3").getDuration().compareTo(config.getParameters().getChallengeWindow()) > 0);
+        actions.add(ActionStatus.recommended("A3", suggestA3,
+                suggestA3 ? "满足派警条件（待G规则确认）" : "未满足派警条件", null));
+        return actions;
+    }
+
+    private List<GRuleStatus> evaluateGRules(Map<String, FRuleEvaluation> fEvaluations,
+                                             RiskModelConfig.PriorityDefinition priority,
+                                             List<ActionStatus> actions,
+                                             List<ImsiRecordEntity> imsiWindow,
+                                             List<CameraAlarmEntity> cameraWindow,
+                                             Instant now,
+                                             RiskModelConfig config) {
+        List<GRuleStatus> statuses = new ArrayList<>();
+        Duration challenge = config.getParameters().getChallengeWindow();
+
+        boolean g1 = priority != null && "P1".equalsIgnoreCase(priority.getId());
+        statuses.add(new GRuleStatus("G1", g1,
+                g1 ? "P1事件立即派警" : "未达到P1"));
+
+        boolean a2Executed = actions.stream().anyMatch(action -> "A2".equals(action.getId()) && action.isTriggered());
+        boolean persists = persistsAcrossChallenge(imsiWindow, cameraWindow, now, challenge);
+        boolean g2 = a2Executed && persists;
+        statuses.add(new GRuleStatus("G2", g2,
+                g2 ? "挑战窗口后目标未离开" : "未满足挑战失败条件"));
+
+        Instant repeatStart = now.minus(config.getParameters().getRepeatWindow());
+        long priorHigh = riskAssessmentRepository.findTop200ByOrderByUpdatedAtDesc().stream()
+                .filter(entity -> entity.getUpdatedAt() != null)
+                .filter(entity -> !entity.getUpdatedAt().isBefore(repeatStart) && entity.getUpdatedAt().isBefore(now))
+                .filter(entity -> {
+                    String cls = Optional.ofNullable(entity.getClassification()).orElse("");
+                    return cls.equalsIgnoreCase("P1") || cls.equalsIgnoreCase("P2");
+                })
                 .count();
-    }
-
-    private List<Integer> computeArrivalHistory(Map<String, Instant> firstSeen, Instant anchor) {
-        if (firstSeen.isEmpty() || anchor == null) {
-            return Collections.emptyList();
-        }
-        List<Integer> samples = new ArrayList<>();
-        Instant windowEnd = anchor.minusMillis(1);
-        for (int i = 0; i < ARRIVAL_HISTORY_SAMPLES; i++) {
-            Instant windowStart = windowEnd.minus(ARRIVAL_HISTORY_WINDOW);
-            samples.add(countArrivals(firstSeen, windowStart, windowEnd));
-            windowEnd = windowStart.minusMillis(1);
+        boolean g3 = priorHigh + (priority != null && ("P1".equalsIgnoreCase(priority.getId()) || "P2".equalsIgnoreCase(priority.getId())) ? 1 : 0)
+                >= config.getParameters().getRepeatThreshold();
+        statuses.add(new GRuleStatus("G3", g3,
+                g3 ? "重复侵扰达到阈值" : "未达到重复侵扰阈值"));
+        return statuses;
+    }
+
+    private void updateActionsWithDispatch(List<ActionStatus> actions, List<GRuleStatus> gStatuses) {
+        boolean dispatch = gStatuses.stream().anyMatch(GRuleStatus::isTriggered);
+        actions.stream()
+                .filter(action -> "A3".equals(action.getId()))
+                .findFirst()
+                .ifPresent(action -> action.setTriggered(dispatch));
+    }
+
+    private String deriveState(Map<String, FRuleEvaluation> fEvaluations,
+                               List<ActionStatus> actions,
+                               List<GRuleStatus> gStatuses) {
+        boolean anyF = fEvaluations.values().stream().anyMatch(FRuleEvaluation::isTriggered);
+        boolean a2 = actions.stream().anyMatch(action -> "A2".equals(action.getId()) && action.isTriggered());
+        boolean a3 = actions.stream().anyMatch(action -> "A3".equals(action.getId()) && action.isTriggered());
+        if (a3) {
+            return "DISPATCHED";
+        }
+        if (a2) {
+            return "CHALLENGE";
+        }
+        if (anyF) {
+            return "MONITORING";
+        }
+        return "IDLE";
+    }
+
+    private String buildSummary(RiskModelConfig.PriorityDefinition priority,
+                                Map<String, FRuleEvaluation> fEvaluations,
+                                List<ActionStatus> actions,
+                                List<GRuleStatus> gStatuses) {
+        String priorityLabel = priority != null ? priority.getId() + " " + Optional.ofNullable(priority.getName()).orElse("") : "P4 低优先级";
+        List<String> segments = new ArrayList<>();
+        segments.add(priorityLabel.trim());
+
+        List<String> ruleHits = fEvaluations.values().stream()
+                .filter(FRuleEvaluation::isTriggered)
+                .map(FRuleEvaluation::getReason)
+                .filter(Objects::nonNull)
+                .collect(Collectors.toList());
+        if (!ruleHits.isEmpty()) {
+            segments.add(String.join("；", ruleHits));
         }
-        Collections.reverse(samples);
-        return samples;
-    }
 
-    private double computeZScore(int current, List<Integer> history) {
-        if (history == null || history.size() < 3) {
-            return 0.0;
-        }
-        double mean = history.stream().mapToInt(Integer::intValue).average().orElse(0);
-        double variance = history.stream()
-                .mapToDouble(value -> Math.pow(value - mean, 2))
-                .average()
-                .orElse(0);
-        double std = Math.sqrt(variance);
-        if (std < 1e-6) {
-            return 0.0;
+        boolean dispatch = gStatuses.stream().anyMatch(GRuleStatus::isTriggered);
+        if (dispatch) {
+            segments.add("已触发派警");
+        } else if (actions.stream().anyMatch(action -> "A2".equals(action.getId()) && action.isTriggered())) {
+            segments.add("已执行远程挑战，等待反馈");
+        } else if (actions.stream().anyMatch(ActionStatus::isTriggered)) {
+            segments.add("保持监控记录");
         }
-        return (current - mean) / std;
+        return String.join(" ｜ ", segments);
     }
 
-    private String imsiKey(ImsiRecordEntity record) {
-        if (record == null) {
-            return null;
-        }
-        if (hasText(record.getImsi())) {
-            return record.getImsi();
+    private FRuleEvaluation evaluateF1(List<CameraAlarmEntity> window, RiskModelConfig.Parameters parameters) {
+        List<CameraAlarmEntity> general = window.stream()
+                .filter(alarm -> !isCoreAlarm(alarm))
+                .sorted(Comparator.comparing(CameraAlarmEntity::getCreatedAt))
+                .collect(Collectors.toList());
+        if (general.isEmpty()) {
+            return FRuleEvaluation.notTriggered("F1");
         }
-        return record.getDeviceId();
-    }
-
-    private static boolean hasText(String value) {
-        return value != null && !value.trim().isEmpty();
-    }
-
-    private enum TimeBand {
-        DAY,
-        DUSK,
-        NIGHT
+        List<Instant> timestamps = general.stream()
+                .map(CameraAlarmEntity::getCreatedAt)
+                .collect(Collectors.toList());
+        long occurrences = countDistinctEvents(timestamps, parameters.getCameraCooldown());
+        Instant first = timestamps.get(0);
+        Instant last = timestamps.get(timestamps.size() - 1);
+        Map<String, Object> metrics = Map.of(
+                "events", general.size(),
+                "channels", collectDistinct(general.stream().map(CameraAlarmEntity::getCamChannel)
+                        .filter(Objects::nonNull)
+                        .collect(Collectors.toSet()))
+        );
+        return new FRuleEvaluation("F1", occurrences > 0, occurrences, first, last,
+                "摄像头检测到一般保护区闯入", metrics, "P3");
     }
 
-    private static class ScoreAccumulator {
-        private final List<RuleHit> scoreHits = new ArrayList<>();
-        private final List<RuleHit> directBlackRules = new ArrayList<>();
-        private final List<RuleHit> strongAlertRules = new ArrayList<>();
-        private int timeScore;
-        private int imsiScore;
-        private int radarScore;
-        private int cameraScore;
-        private int fusionScore;
-        private int baselineScore;
-        private boolean forceStrongAlert;
-
-        void addTimeScore(String id, int value, String description) {
-            if (value <= 0) {
-                return;
-            }
-            timeScore += value;
-            scoreHits.add(new RuleHit(id, value, description));
-        }
-
-        void mergeImsi(List<RuleHit> hits) {
-            for (RuleHit hit : hits) {
-                imsiScore += hit.getScore();
-                scoreHits.add(hit);
-            }
-        }
-
-        void mergeCamera(List<RuleHit> hits) {
-            for (RuleHit hit : hits) {
-                cameraScore += hit.getScore();
-                scoreHits.add(hit);
-            }
+    private FRuleEvaluation evaluateF4(List<CameraAlarmEntity> window, RiskModelConfig.Parameters parameters) {
+        List<CameraAlarmEntity> core = window.stream()
+                .filter(this::isCoreAlarm)
+                .sorted(Comparator.comparing(CameraAlarmEntity::getCreatedAt))
+                .collect(Collectors.toList());
+        if (core.isEmpty()) {
+            return FRuleEvaluation.notTriggered("F4");
         }
+        List<Instant> timestamps = core.stream()
+                .map(CameraAlarmEntity::getCreatedAt)
+                .collect(Collectors.toList());
+        long occurrences = countDistinctEvents(timestamps, parameters.getCameraCooldown());
+        Instant first = timestamps.get(0);
+        Instant last = timestamps.get(timestamps.size() - 1);
+        Map<String, Object> metrics = Map.of(
+                "events", core.size(),
+                "channels", collectDistinct(core.stream().map(CameraAlarmEntity::getCamChannel)
+                        .filter(Objects::nonNull)
+                        .collect(Collectors.toSet()))
+        );
+        return new FRuleEvaluation("F4", occurrences > 0, occurrences, first, last,
+                "核心区域越界触发", metrics, "P1");
+    }
 
-        void mergeRadar(List<RuleHit> hits) {
-            for (RuleHit hit : hits) {
-                int allowed = Math.min(hit.getScore(), RADAR_SCORE_CAP - radarScore);
-                if (allowed <= 0) {
-                    continue;
-                }
-                radarScore += allowed;
-                scoreHits.add(new RuleHit(hit.getId(), allowed, hit.getDescription()));
+    private FRuleEvaluation evaluateF2(List<ImsiRecordEntity> window,
+                                       List<ImsiRecordEntity> history,
+                                       Instant windowStart,
+                                       RiskModelConfig.Parameters parameters) {
+        Map<String, List<Instant>> groupedWindow = window.stream()
+                .filter(rec -> rec.getFetchedAt() != null)
+                .collect(Collectors.groupingBy(this::imsiKey,
+                        Collectors.mapping(ImsiRecordEntity::getFetchedAt, Collectors.toList())));
+        if (groupedWindow.isEmpty()) {
+            return FRuleEvaluation.notTriggered("F2");
+        }
+        Set<String> seenBeforeWindow = history.stream()
+                .filter(rec -> rec.getFetchedAt() != null && rec.getFetchedAt().isBefore(windowStart))
+                .map(this::imsiKey)
+                .collect(Collectors.toSet());
+        Set<String> newDevices = groupedWindow.entrySet().stream()
+                .filter(entry -> entry.getValue().stream().anyMatch(ts -> !ts.isBefore(windowStart)))
+                .filter(entry -> !seenBeforeWindow.contains(entry.getKey()))
+                .map(Map.Entry::getKey)
+                .collect(Collectors.toCollection(() -> new TreeSet<>(String::compareTo)));
+        if (newDevices.isEmpty()) {
+            return FRuleEvaluation.notTriggered("F2");
+        }
+        Instant first = groupedWindow.get(newDevices.iterator().next()).stream()
+                .min(Instant::compareTo)
+                .orElse(windowStart);
+        Instant last = newDevices.stream()
+                .map(key -> groupedWindow.getOrDefault(key, List.of()).stream().max(Instant::compareTo).orElse(windowStart))
+                .max(Instant::compareTo)
+                .orElse(first);
+        Map<String, Object> metrics = new HashMap<>();
+        metrics.put("newDevices", newDevices);
+        metrics.put("totalHits", groupedWindow.values().stream().mapToInt(List::size).sum());
+        return new FRuleEvaluation("F2", true, newDevices.size(), first, last,
+                String.format(Locale.CHINA, "检测到%d个未知IMSI", newDevices.size()), metrics, "P3");
+    }
+
+    private FRuleEvaluation evaluateF3(List<ImsiRecordEntity> window,
+                                       List<ImsiRecordEntity> history,
+                                       Instant windowStart,
+                                       RiskModelConfig.Parameters parameters) {
+        Duration dwellThreshold = parameters.getImsiDwellThreshold();
+        Duration reentryWindow = parameters.getImsiReentryWindow();
+        Map<String, List<Instant>> groupedWindow = window.stream()
+                .filter(rec -> rec.getFetchedAt() != null)
+                .collect(Collectors.groupingBy(this::imsiKey,
+                        Collectors.mapping(ImsiRecordEntity::getFetchedAt, Collectors.toList())));
+        if (groupedWindow.isEmpty()) {
+            return FRuleEvaluation.notTriggered("F3");
+        }
+        Map<String, Instant> lastBeforeWindow = history.stream()
+                .filter(rec -> rec.getFetchedAt() != null && rec.getFetchedAt().isBefore(windowStart))
+                .collect(Collectors.groupingBy(this::imsiKey,
+                        Collectors.collectingAndThen(Collectors.maxBy(Comparator.comparing(ImsiRecordEntity::getFetchedAt)),
+                                opt -> opt.map(ImsiRecordEntity::getFetchedAt).orElse(null))));
+
+        boolean triggered = false;
+        Instant firstTrigger = null;
+        Instant lastTrigger = null;
+        String reason = null;
+        Map<String, Object> metrics = new HashMap<>();
+        List<String> offenders = new ArrayList<>();
+
+        for (Map.Entry<String, List<Instant>> entry : groupedWindow.entrySet()) {
+            List<Instant> hits = entry.getValue().stream().sorted().collect(Collectors.toList());
+            if (hits.isEmpty()) {
+                continue;
             }
-        }
-
-        void mergeFusion(List<RuleHit> hits) {
-            for (RuleHit hit : hits) {
-                int allowed = Math.min(hit.getScore(), FUSION_SCORE_CAP - fusionScore);
-                if (allowed <= 0) {
-                    continue;
+            Instant first = hits.get(0);
+            Instant last = hits.get(hits.size() - 1);
+            Duration stay = Duration.between(first, last);
+            boolean dwell = stay.compareTo(dwellThreshold) >= 0;
+            Instant previous = lastBeforeWindow.get(entry.getKey());
+            boolean reentry = previous != null && Duration.between(previous, first).compareTo(reentryWindow) <= 0;
+            if (dwell || reentry || hits.size() >= 3) {
+                triggered = true;
+                firstTrigger = firstTrigger == null ? first : firstTrigger;
+                lastTrigger = last.isAfter(Optional.ofNullable(lastTrigger).orElse(Instant.MIN)) ? last : lastTrigger;
+                offenders.add(entry.getKey());
+                if (reason == null) {
+                    if (dwell) {
+                        reason = "IMSI持续停留超过阈值";
+                    } else if (reentry) {
+                        reason = "IMSI在再识别窗口内重返";
+                    } else {
+                        reason = "IMSI在窗口内多次出现";
+                    }
                 }
-                fusionScore += allowed;
-                scoreHits.add(new RuleHit(hit.getId(), allowed, hit.getDescription()));
-            }
-        }
-
-        void addBaseline(String id, int value, String description) {
-            if (value <= 0) {
-                return;
             }
-            baselineScore += value;
-            scoreHits.add(new RuleHit(id, value, description));
-        }
-
-        void markDirectBlack(String id, String description) {
-            directBlackRules.add(new RuleHit(id, 0, description));
-        }
-
-        void forceStrongAlert(String id, String description) {
-            forceStrongAlert = true;
-            strongAlertRules.add(new RuleHit(id, 0, description));
-        }
-
-        int getTotalScore() {
-            return timeScore + imsiScore + radarScore + cameraScore + fusionScore + baselineScore;
-        }
-
-        List<RuleHit> getScoreHits() {
-            return scoreHits;
         }
-
-        List<RuleHit> getDirectBlackRules() {
-            return directBlackRules;
-        }
-
-        List<RuleHit> getStrongAlertRules() {
-            return strongAlertRules;
-        }
-
-        boolean isForceStrongAlert() {
-            return forceStrongAlert;
-        }
-
-        String getTopRuleDescription() {
-            return scoreHits.isEmpty() ? null : scoreHits.get(0).getDescription();
+        if (!triggered) {
+            return FRuleEvaluation.notTriggered("F3");
         }
+        metrics.put("devices", offenders);
+        metrics.put("count", offenders.size());
+        return new FRuleEvaluation("F3", true, offenders.size(),
+                Optional.ofNullable(firstTrigger).orElse(windowStart),
+                Optional.ofNullable(lastTrigger).orElse(windowStart),
+                reason, metrics, "P2");
     }
 
-    private static class RuleHit {
-        private final String id;
-        private final int score;
-        private final String description;
-
-        RuleHit(String id, int score, String description) {
-            this.id = id;
-            this.score = score;
-            this.description = description;
-        }
-
-        public String getId() {
-            return id;
-        }
-
-        public int getScore() {
-            return score;
+    private long countDistinctEvents(List<Instant> timestamps, Duration cooldown) {
+        if (timestamps.isEmpty()) {
+            return 0;
         }
-
-        public String getDescription() {
-            return description;
+        Instant last = null;
+        long count = 0;
+        for (Instant ts : timestamps) {
+            if (last == null || Duration.between(last, ts).compareTo(cooldown) > 0) {
+                count++;
+                last = ts;
+            }
         }
+        return count;
     }
 
-    private static class ImsiContext {
-        private final List<ImsiDeviceMetrics> devices;
-        private final ImsiDeviceMetrics topDevice;
-        private final int arrivals10;
-        private final int arrivalsTight;
-        private final double arrivalZ;
-        private final List<Integer> arrivalHistory;
-        private final boolean highDetectability;
-        private final boolean nightOuterDwell;
-        private final List<RuleHit> scoreHits;
-
-        ImsiContext(List<ImsiDeviceMetrics> devices,
-                    ImsiDeviceMetrics topDevice,
-                    int arrivals10,
-                    int arrivalsTight,
-                    double arrivalZ,
-                    List<Integer> arrivalHistory,
-                    boolean highDetectability,
-                    boolean nightOuterDwell,
-                    List<RuleHit> scoreHits) {
-            this.devices = devices;
-            this.topDevice = topDevice;
-            this.arrivals10 = arrivals10;
-            this.arrivalsTight = arrivalsTight;
-            this.arrivalZ = arrivalZ;
-            this.arrivalHistory = arrivalHistory;
-            this.highDetectability = highDetectability;
-            this.nightOuterDwell = nightOuterDwell;
-            this.scoreHits = scoreHits;
-        }
-
-        Map<String, Object> toMetadata() {
-            Map<String, Object> map = new LinkedHashMap<>();
-            map.put("devices", devices.stream().map(ImsiDeviceMetrics::toMetadata).collect(Collectors.toList()));
-            map.put("topDevice", topDevice != null ? topDevice.toMetadata() : null);
-            map.put("arrivals10", arrivals10);
-            map.put("arrivalsTight", arrivalsTight);
-            map.put("arrivalZ", arrivalZ);
-            map.put("arrivalHistory", arrivalHistory);
-            map.put("highDetectability", highDetectability);
-            map.put("nightOuterDwell", nightOuterDwell);
-            map.put("highRiskDeviceCount", getHighRiskDeviceCount());
-            return map;
-        }
-
-        int getArrivals10() {
-            return arrivals10;
-        }
-
-        int getArrivalsTight() {
-            return arrivalsTight;
-        }
-
-        double getArrivalZ() {
-            return arrivalZ;
-        }
-
-        boolean isHighDetectability() {
-            return highDetectability;
-        }
-
-        boolean isNightOuterDwell() {
-            return nightOuterDwell;
-        }
-
-        int getHighRiskDeviceCount() {
-            return (int) devices.stream().filter(d -> d.getBucketCount() >= 2).count();
-        }
-
-        List<RuleHit> getScoreHits() {
-            return scoreHits;
-        }
+    private boolean persistsAcrossChallenge(List<ImsiRecordEntity> imsiWindow,
+                                            List<CameraAlarmEntity> cameraWindow,
+                                            Instant now,
+                                            Duration challengeWindow) {
+        Instant threshold = now.minus(challengeWindow);
+        boolean imsiPersist = imsiWindow.stream()
+                .map(ImsiRecordEntity::getFetchedAt)
+                .filter(Objects::nonNull)
+                .anyMatch(ts -> !ts.isBefore(threshold));
+        boolean cameraPersist = cameraWindow.stream()
+                .map(CameraAlarmEntity::getCreatedAt)
+                .filter(Objects::nonNull)
+                .anyMatch(ts -> !ts.isBefore(threshold));
+        boolean imsiHistoric = imsiWindow.stream()
+                .map(ImsiRecordEntity::getFetchedAt)
+                .filter(Objects::nonNull)
+                .anyMatch(ts -> ts.isBefore(threshold));
+        boolean cameraHistoric = cameraWindow.stream()
+                .map(CameraAlarmEntity::getCreatedAt)
+                .filter(Objects::nonNull)
+                .anyMatch(ts -> ts.isBefore(threshold));
+        return (imsiPersist && imsiHistoric) || (cameraPersist && cameraHistoric);
+    }
 
-        ImsiDeviceMetrics getTopDevice() {
-            return topDevice;
-        }
+    private boolean isCoreAlarm(CameraAlarmEntity alarm) {
+        String type = normalize(alarm.getEventType());
+        String level = normalize(alarm.getLevel());
+        String channel = normalize(alarm.getCamChannel());
+        return containsAny(type, "core", "aoi", "perimeter", "fence", "line", "boundary")
+                || containsAny(level, "high", "critical", "p1", "major")
+                || containsAny(channel, "core", "aoi", "inner");
     }
 
-    private static class ImsiDeviceMetrics {
-        private final String key;
-        private final int bucketCount;
-        private final boolean hasLongGap;
-        private final boolean hasRevisit;
-        private final TimeBand dominantBand;
-        private final int score;
-        private final List<RuleHit> ruleHits;
-        private final Instant start;
-        private final Instant end;
-
-        ImsiDeviceMetrics(String key,
-                          List<ImsiRecordEntity> bursts,
-                          List<ImsiSession> sessions,
-                          Instant windowStart,
-                          Instant windowEnd) {
-            this.key = key;
-            this.start = bursts.isEmpty() ? null : bursts.get(0).getFetchedAt();
-            this.end = bursts.isEmpty() ? null : bursts.get(bursts.size() - 1).getFetchedAt();
-            List<Instant> windowBursts = bursts.stream()
-                    .map(ImsiRecordEntity::getFetchedAt)
-                    .filter(ts -> ts != null && !ts.isBefore(windowStart) && !ts.isAfter(windowEnd))
-                    .collect(Collectors.toList());
-            this.bucketCount = new LinkedHashSet<>(windowBursts.stream()
-                    .map(instant -> truncateToBucket(instant))
-                    .filter(Objects::nonNull)
-                    .collect(Collectors.toList())).size();
-            this.hasLongGap = sessions.stream().anyMatch(ImsiSession::hasLongGapWithinSession);
-            this.hasRevisit = hasRevisit(sessions);
-            this.dominantBand = determineDominantBand(windowBursts);
-            this.ruleHits = new ArrayList<>();
-            int total = 0;
-            if (bucketCount == 1) {
-                ruleHits.add(new RuleHit("B1", 2, key + " 命中 1 桶"));
-                total += 2;
-            } else if (bucketCount == 2) {
-                ruleHits.add(new RuleHit("B2", 8, key + " 命中 2 桶"));
-                total += 8;
-            } else if (bucketCount == 3) {
-                ruleHits.add(new RuleHit("B3", 14, key + " 命中 3 桶"));
-                total += 14;
-            } else if (bucketCount >= 4) {
-                ruleHits.add(new RuleHit("B4", 20, key + " 命中 ≥4 桶"));
-                total += 20;
-            }
-            if (hasLongGap) {
-                ruleHits.add(new RuleHit("C1", 4, key + " 会话内 ≥12min 间隔"));
-                total += 4;
-            }
-            if (hasRevisit) {
-                ruleHits.add(new RuleHit("C2", 6, key + " 15min+ 断开后 2h 内重返"));
-                total += 6;
-            }
-            this.score = total;
-        }
+    private String normalize(String value) {
+        return value == null ? "" : value.toLowerCase(Locale.ROOT);
+    }
 
-        private boolean hasRevisit(List<ImsiSession> sessions) {
-            if (sessions.size() < 2) {
-                return false;
+    private boolean containsAny(String text, String... keywords) {
+        for (String keyword : keywords) {
+            if (text.contains(keyword)) {
+                return true;
             }
-            for (int i = 1; i < sessions.size(); i++) {
-                ImsiSession prev = sessions.get(i - 1);
-                ImsiSession curr = sessions.get(i);
-                if (prev.getEnd() != null && curr.getStart() != null) {
-                    long gapMinutes = Duration.between(prev.getEnd(), curr.getStart()).toMinutes();
-                    if (gapMinutes > SESSION_BREAK.toMinutes() && gapMinutes <= Duration.ofHours(2).toMinutes()) {
-                        return true;
-                    }
-                }
-            }
-            return false;
-        }
-
-        Map<String, Object> toMetadata() {
-            Map<String, Object> map = new LinkedHashMap<>();
-            map.put("key", key);
-            map.put("bucketCount", bucketCount);
-            map.put("hasLongGap", hasLongGap);
-            map.put("hasRevisit", hasRevisit);
-            map.put("score", score);
-            map.put("dominantBand", dominantBand.name());
-            map.put("start", start);
-            map.put("end", end);
-            return map;
-        }
-
-        int getBucketCount() {
-            return bucketCount;
-        }
-
-        TimeBand getDominantBand() {
-            return dominantBand;
-        }
-
-        int getScore() {
-            return score;
         }
+        return false;
+    }
 
-        boolean isNightWindow() {
-            return dominantBand == TimeBand.NIGHT;
+    private String imsiKey(ImsiRecordEntity entity) {
+        if (entity.getImsi() != null && !entity.getImsi().isEmpty()) {
+            return entity.getImsi();
         }
-
-        List<RuleHit> getRuleHits() {
-            return ruleHits;
+        if (entity.getDeviceId() != null && !entity.getDeviceId().isEmpty()) {
+            return "DEV-" + entity.getDeviceId();
         }
+        return "UNKNOWN";
     }
 
-    private static Instant truncateToBucket(Instant instant) {
-        if (instant == null) {
-            return null;
-        }
-        long epoch = instant.getEpochSecond();
-        long bucket = Math.floorDiv(epoch, TIME_BUCKET.getSeconds()) * TIME_BUCKET.getSeconds();
-        return Instant.ofEpochSecond(bucket);
+    private int countDistinctImsi(List<ImsiRecordEntity> window) {
+        return (int) window.stream()
+                .map(this::imsiKey)
+                .collect(Collectors.toSet())
+                .size();
     }
 
-    private static class ImsiSession {
-        private final List<ImsiRecordEntity> records = new ArrayList<>();
-        private boolean hasLongGapWithinSession;
-
-        void add(ImsiRecordEntity record) {
-            records.add(record);
-        }
-
-        Instant getStart() {
-            return records.isEmpty() ? null : records.get(0).getFetchedAt();
-        }
-
-        Instant getEnd() {
-            return records.isEmpty() ? null : records.get(records.size() - 1).getFetchedAt();
-        }
-
-        long getDurationMinutes() {
-            if (records.isEmpty()) {
-                return 0;
-            }
-            Instant start = getStart();
-            Instant end = getEnd();
-            if (start == null || end == null) {
-                return 0;
-            }
-            return Math.max(0, Duration.between(start, end).toMinutes());
-        }
-
-        boolean hasLongGapWithinSession() {
-            return hasLongGapWithinSession;
-        }
-
-        void setHasLongGapWithinSession(boolean value) {
-            this.hasLongGapWithinSession = value;
-        }
+    private List<String> collectDistinct(Set<String> input) {
+        return input.stream().sorted().collect(Collectors.toList());
     }
 
-    private static class CameraSession {
-        private final Instant start;
-        private Instant end;
-
-        CameraSession(Instant start, Instant end) {
-            this.start = start;
-            this.end = end;
+    private static class FRuleEvaluation {
+        private final String id;
+        private final boolean triggered;
+        private final long occurrences;
+        private final Instant firstSeen;
+        private final Instant lastSeen;
+        private final String reason;
+        private final Map<String, Object> metrics;
+        private final String escalatesTo;
+
+        private FRuleEvaluation(String id,
+                                 boolean triggered,
+                                 long occurrences,
+                                 Instant firstSeen,
+                                 Instant lastSeen,
+                                 String reason,
+                                 Map<String, Object> metrics,
+                                 String escalatesTo) {
+            this.id = id;
+            this.triggered = triggered;
+            this.occurrences = occurrences;
+            this.firstSeen = firstSeen;
+            this.lastSeen = lastSeen;
+            this.reason = reason;
+            this.metrics = metrics != null ? metrics : Map.of();
+            this.escalatesTo = escalatesTo;
         }
 
-        Instant getStart() {
-            return start;
+        static FRuleEvaluation notTriggered(String id) {
+            return new FRuleEvaluation(id, false, 0, null, null, null, Map.of(), null);
         }
 
-        Instant getEnd() {
-            return end;
+        public boolean isTriggered() {
+            return triggered;
         }
 
-        void setEnd(Instant end) {
-            this.end = end;
+        public String getReason() {
+            return reason;
         }
 
-        long getDurationSeconds() {
-            if (start == null || end == null) {
-                return 0;
-            }
-            return Math.max(0, Duration.between(start, end).getSeconds());
+        public String getEscalatesTo() {
+            return escalatesTo;
         }
-    }
 
-    private static class CameraContext {
-        private final boolean enteredAoi;
-        private final boolean nightLongStay;
-        private final boolean nightReentry;
-        private final boolean multiPersonHint;
-        private final boolean nightWindow;
-        private final long edgeLoopCount;
-        private final List<RuleHit> scoreHits;
-        private final List<CameraSession> sessions;
-        private final TimeBand band;
-
-        CameraContext(boolean enteredAoi,
-                      boolean nightLongStay,
-                      boolean nightReentry,
-                      boolean multiPersonHint,
-                      boolean nightWindow,
-                      long edgeLoopCount,
-                      List<RuleHit> scoreHits,
-                      List<CameraSession> sessions,
-                      TimeBand band) {
-            this.enteredAoi = enteredAoi;
-            this.nightLongStay = nightLongStay;
-            this.nightReentry = nightReentry;
-            this.multiPersonHint = multiPersonHint;
-            this.nightWindow = nightWindow;
-            this.edgeLoopCount = edgeLoopCount;
-            this.scoreHits = scoreHits;
-            this.sessions = sessions;
-            this.band = band;
+        public Duration getDuration() {
+            if (firstSeen == null || lastSeen == null) {
+                return Duration.ZERO;
+            }
+            return Duration.between(firstSeen, lastSeen);
         }
 
-        Map<String, Object> toMetadata() {
+        public Map<String, Object> toMap(RiskModelConfig.PriorityDefinition priority) {
             Map<String, Object> map = new LinkedHashMap<>();
-            map.put("enteredAoi", enteredAoi);
-            map.put("nightLongStay", nightLongStay);
-            map.put("nightReentry", nightReentry);
-            map.put("multiPersonHint", multiPersonHint);
-            map.put("nightWindow", nightWindow);
-            map.put("edgeLoopCount", edgeLoopCount);
-            List<Map<String, Object>> sessionMeta = new ArrayList<>();
-            for (CameraSession session : sessions) {
-                Map<String, Object> item = new LinkedHashMap<>();
-                item.put("start", session.getStart());
-                item.put("end", session.getEnd());
-                item.put("durationSeconds", session.getDurationSeconds());
-                sessionMeta.add(item);
+            map.put("id", id);
+            map.put("triggered", triggered);
+            map.put("occurrences", occurrences);
+            map.put("firstSeen", firstSeen);
+            map.put("lastSeen", lastSeen);
+            map.put("duration", getDuration());
+            map.put("reason", reason);
+            map.put("metrics", metrics);
+            map.put("escalatesTo", escalatesTo);
+            if (priority != null) {
+                map.put("priority", priority);
             }
-            map.put("sessions", sessionMeta);
-            map.put("band", band.name());
             return map;
         }
-
-        boolean isEnteredAoi() {
-            return enteredAoi;
-        }
-
-        boolean isNightWindow() {
-            return nightWindow;
-        }
-
-        boolean isNightLongStay() {
-            return nightLongStay;
-        }
-
-        boolean isNightReentry() {
-            return nightReentry;
-        }
-
-        boolean isMultiPersonHint() {
-            return multiPersonHint;
-        }
-
-        List<RuleHit> getScoreHits() {
-            return scoreHits;
-        }
     }
 
-    private static class RadarTrack {
-        private final List<RadarTargetEntity> events;
-        private final Duration duration;
-        private final boolean approachAndDisappear;
-        private final boolean intermittent;
-        private final boolean hasNearApproach;
-        private final Instant start;
-        private final Instant end;
-
-        RadarTrack(List<RadarTargetEntity> events) {
-            this.events = events;
-            if (events.isEmpty()) {
-                this.duration = Duration.ZERO;
-                this.approachAndDisappear = false;
-                this.intermittent = false;
-                this.hasNearApproach = false;
-                this.start = null;
-                this.end = null;
-                return;
-            }
-            this.start = events.get(0).getCapturedAt();
-            this.end = events.get(events.size() - 1).getCapturedAt();
-            this.duration = (start != null && end != null) ? Duration.between(start, end) : Duration.ZERO;
-
-            boolean near = false;
-            Instant lastNear = null;
-            Instant previous = null;
-            boolean intermittentFlag = false;
-            for (RadarTargetEntity event : events) {
-                Instant ts = event.getCapturedAt();
-                if (ts == null) {
-                    continue;
-                }
-                Double range = event.getRange();
-                if (range == null) {
-                    Double longitudinal = event.getLongitudinalDistance();
-                    Double lateral = event.getLateralDistance();
-                    if (longitudinal != null || lateral != null) {
-                        double lon = longitudinal != null ? longitudinal : 0.0;
-                        double lat = lateral != null ? lateral : 0.0;
-                        range = Math.sqrt(lon * lon + lat * lat);
-                    }
-                }
-                if (range != null && range <= RADAR_NEAR_DISTANCE) {
-                    near = true;
-                    lastNear = ts;
-                }
-                if (previous != null) {
-                    Duration gap = Duration.between(previous, ts);
-                    if (gap.compareTo(RADAR_INTERMITTENT_WINDOW) > 0) {
-                        intermittentFlag = true;
-                    }
-                }
-                previous = ts;
-            }
-            this.hasNearApproach = near;
-            this.intermittent = intermittentFlag;
-            if (near && lastNear != null) {
-                final Instant finalLastNear = lastNear;
-                boolean disappear = events.stream()
-                        .map(RadarTargetEntity::getCapturedAt)
-                        .filter(Objects::nonNull)
-                        .noneMatch(ts -> !ts.equals(finalLastNear)
-                                && !ts.isBefore(finalLastNear)
-                                && Duration.between(finalLastNear, ts).compareTo(RADAR_INTERMITTENT_WINDOW) <= 0);
-                this.approachAndDisappear = disappear;
-            } else {
-                this.approachAndDisappear = false;
-            }
-        }
-
-        Duration getDuration() {
-            return duration;
-        }
-
-        boolean isApproachAndDisappear() {
-            return approachAndDisappear;
-        }
+    private static class ActionStatus {
+        private final String id;
+        private final boolean recommended;
+        private boolean triggered;
+        private final String rationale;
+        private final Instant decidedAt;
 
-        boolean isIntermittent() {
-            return intermittent;
+        private ActionStatus(String id, boolean recommended, boolean triggered, String rationale, Instant decidedAt) {
+            this.id = id;
+            this.recommended = recommended;
+            this.triggered = triggered;
+            this.rationale = rationale;
+            this.decidedAt = decidedAt;
         }
 
-        boolean hasNearApproach() {
-            return hasNearApproach;
+        static ActionStatus recommended(String id, boolean recommended, String rationale, Instant decidedAt) {
+            return new ActionStatus(id, recommended, recommended, rationale, decidedAt);
         }
 
-        boolean overlaps(RadarTrack other) {
-            if (this.start == null || this.end == null || other.start == null || other.end == null) {
-                return false;
-            }
-            return !(this.end.isBefore(other.start) || other.end.isBefore(this.start));
+        public String getId() {
+            return id;
         }
-    }
 
-    private static class RadarContext {
-        private final List<RuleHit> scoreHits;
-        private final boolean approachDisappear;
-        private final int approachTracks;
-        private final TimeBand band;
-
-        RadarContext(List<RuleHit> scoreHits,
-                     boolean approachDisappear,
-                     int approachTracks,
-                     TimeBand band) {
-            this.scoreHits = scoreHits;
-            this.approachDisappear = approachDisappear;
-            this.approachTracks = approachTracks;
-            this.band = band;
+        public boolean isTriggered() {
+            return triggered;
         }
 
-        static RadarContext empty() {
-            return new RadarContext(Collections.emptyList(), false, 0, TimeBand.DAY);
+        public void setTriggered(boolean triggered) {
+            this.triggered = triggered;
         }
 
-        Map<String, Object> toMetadata() {
+        public Map<String, Object> toMap(ActionDefinition definition) {
             Map<String, Object> map = new LinkedHashMap<>();
-            map.put("band", band.name());
-            map.put("approachDisappear", approachDisappear);
-            map.put("approachTracks", approachTracks);
-            List<Map<String, Object>> ruleMeta = new ArrayList<>();
-            for (RuleHit hit : scoreHits) {
-                Map<String, Object> item = new LinkedHashMap<>();
-                item.put("id", hit.getId());
-                item.put("score", hit.getScore());
-                item.put("desc", hit.getDescription());
-                ruleMeta.add(item);
+            map.put("id", id);
+            map.put("recommended", recommended);
+            map.put("triggered", triggered);
+            map.put("rationale", rationale);
+            map.put("decidedAt", decidedAt);
+            if (definition != null) {
+                map.put("definition", definition);
             }
-            map.put("rules", ruleMeta);
             return map;
         }
-
-        List<RuleHit> getScoreHits() {
-            return scoreHits;
-        }
-
-        boolean isApproachDisappear() {
-            return approachDisappear;
-        }
-
-        int getApproachTracks() {
-            return approachTracks;
-        }
     }
 
-    private static class DayCasingState {
-        private final boolean markActive;
-        private final boolean nightEntryAfterMark;
-        private final Instant latestMark;
-        private final boolean hasMultiDayCasing;
-
-        DayCasingState(boolean markActive,
-                       boolean nightEntryAfterMark,
-                       Instant latestMark,
-                       boolean hasMultiDayCasing) {
-            this.markActive = markActive;
-            this.nightEntryAfterMark = nightEntryAfterMark;
-            this.latestMark = latestMark;
-            this.hasMultiDayCasing = hasMultiDayCasing;
-        }
-
-        Map<String, Object> toMetadata() {
-            Map<String, Object> map = new LinkedHashMap<>();
-            map.put("markActive", markActive);
-            map.put("nightEntryAfterMark", nightEntryAfterMark);
-            map.put("latestMark", latestMark);
-            map.put("multiDayCasing", hasMultiDayCasing);
-            return map;
-        }
+    private static class GRuleStatus {
+        private final String id;
+        private final boolean triggered;
+        private final String rationale;
 
-        boolean isMarkActive() {
-            return markActive;
+        private GRuleStatus(String id, boolean triggered, String rationale) {
+            this.id = id;
+            this.triggered = triggered;
+            this.rationale = rationale;
         }
 
-        boolean shouldDirectBlackOnNightReturn() {
-            return markActive && nightEntryAfterMark;
+        public String getId() {
+            return id;
         }
-    }
 
-    private static class FusionContext {
-        private final List<RuleHit> scoreHits;
-        private final int arrivals10;
-        private final int arrivalsTight;
-        private final double arrivalZ;
-        private final boolean highDetectability;
-        private final List<Instant> history;
-        private final boolean nightGroupInAoi;
-
-        FusionContext(List<RuleHit> scoreHits,
-                      int arrivals10,
-                      int arrivalsTight,
-                      double arrivalZ,
-                      boolean highDetectability,
-                      List<Instant> history,
-                      boolean nightGroupInAoi) {
-            this.scoreHits = scoreHits;
-            this.arrivals10 = arrivals10;
-            this.arrivalsTight = arrivalsTight;
-            this.arrivalZ = arrivalZ;
-            this.highDetectability = highDetectability;
-            this.history = history;
-            this.nightGroupInAoi = nightGroupInAoi;
+        public boolean isTriggered() {
+            return triggered;
         }
 
-        Map<String, Object> toMetadata() {
+        public Map<String, Object> toMap(GRuleDefinition definition) {
             Map<String, Object> map = new LinkedHashMap<>();
-            map.put("arrivals10", arrivals10);
-            map.put("arrivalsTight", arrivalsTight);
-            map.put("arrivalZ", arrivalZ);
-            map.put("highDetectability", highDetectability);
-            map.put("f3f4History", history.stream().map(Instant::toString).collect(Collectors.toList()));
-            map.put("nightGroupInAoi", nightGroupInAoi);
-            List<Map<String, Object>> ruleMeta = new ArrayList<>();
-            for (RuleHit hit : scoreHits) {
-                Map<String, Object> item = new LinkedHashMap<>();
-                item.put("id", hit.getId());
-                item.put("score", hit.getScore());
-                item.put("desc", hit.getDescription());
-                ruleMeta.add(item);
+            map.put("id", id);
+            map.put("triggered", triggered);
+            map.put("rationale", rationale);
+            if (definition != null) {
+                map.put("definition", definition);
             }
-            map.put("rules", ruleMeta);
             return map;
         }
-
-        List<RuleHit> getScoreHits() {
-            return scoreHits;
-        }
-
-        boolean isNightGroupInAoi() {
-            return nightGroupInAoi;
-        }
     }
 }
diff --git a/backend/src/main/java/com/example/nvr/risk/config/RiskModelConfig.java b/backend/src/main/java/com/example/nvr/risk/config/RiskModelConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..17f668850c9b8d6150abeb464b40a8a1a9e4f188
--- /dev/null
+++ b/backend/src/main/java/com/example/nvr/risk/config/RiskModelConfig.java
@@ -0,0 +1,520 @@
+package com.example.nvr.risk.config;
+
+import com.fasterxml.jackson.annotation.JsonIgnore;
+
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+/**
+ * Immutable representation of the YAML 风控模型配置。
+ */
+public class RiskModelConfig {
+
+    private String version;
+    private Parameters parameters;
+    private List<PriorityDefinition> priorities = new ArrayList<>();
+    private List<ActionDefinition> actions = new ArrayList<>();
+    private List<FRuleDefinition> fRules = new ArrayList<>();
+    private List<GRuleDefinition> gRules = new ArrayList<>();
+    private StateMachineDefinition stateMachine = new StateMachineDefinition();
+
+    @JsonIgnore
+    private Map<String, PriorityDefinition> priorityIndex;
+
+    @JsonIgnore
+    private Map<String, ActionDefinition> actionIndex;
+
+    public String getVersion() {
+        return version;
+    }
+
+    public void setVersion(String version) {
+        this.version = version;
+    }
+
+    public Parameters getParameters() {
+        return parameters;
+    }
+
+    public void setParameters(Parameters parameters) {
+        this.parameters = parameters;
+    }
+
+    public List<PriorityDefinition> getPriorities() {
+        return priorities;
+    }
+
+    public void setPriorities(List<PriorityDefinition> priorities) {
+        this.priorities = priorities != null ? new ArrayList<>(priorities) : new ArrayList<>();
+        this.priorityIndex = null;
+    }
+
+    public List<ActionDefinition> getActions() {
+        return actions;
+    }
+
+    public void setActions(List<ActionDefinition> actions) {
+        this.actions = actions != null ? new ArrayList<>(actions) : new ArrayList<>();
+        this.actionIndex = null;
+    }
+
+    public List<FRuleDefinition> getFRules() {
+        return fRules;
+    }
+
+    public void setFRules(List<FRuleDefinition> fRules) {
+        this.fRules = fRules != null ? new ArrayList<>(fRules) : new ArrayList<>();
+    }
+
+    public List<GRuleDefinition> getGRules() {
+        return gRules;
+    }
+
+    public void setGRules(List<GRuleDefinition> gRules) {
+        this.gRules = gRules != null ? new ArrayList<>(gRules) : new ArrayList<>();
+    }
+
+    public StateMachineDefinition getStateMachine() {
+        return stateMachine;
+    }
+
+    public void setStateMachine(StateMachineDefinition stateMachine) {
+        this.stateMachine = stateMachine != null ? stateMachine : new StateMachineDefinition();
+    }
+
+    public PriorityDefinition findPriority(String id) {
+        if (id == null) {
+            return null;
+        }
+        ensurePriorityIndex();
+        return priorityIndex.get(id.toUpperCase());
+    }
+
+    public ActionDefinition findAction(String id) {
+        if (id == null) {
+            return null;
+        }
+        ensureActionIndex();
+        return actionIndex.get(id.toUpperCase());
+    }
+
+    private void ensurePriorityIndex() {
+        if (priorityIndex == null) {
+            Map<String, PriorityDefinition> map = new HashMap<>();
+            for (PriorityDefinition def : priorities) {
+                if (def != null && def.getId() != null) {
+                    map.put(def.getId().toUpperCase(), def);
+                }
+            }
+            priorityIndex = map;
+        }
+    }
+
+    private void ensureActionIndex() {
+        if (actionIndex == null) {
+            Map<String, ActionDefinition> map = new HashMap<>();
+            for (ActionDefinition def : actions) {
+                if (def != null && def.getId() != null) {
+                    map.put(def.getId().toUpperCase(), def);
+                }
+            }
+            actionIndex = map;
+        }
+    }
+
+    public Map<String, Object> toMetadata() {
+        Map<String, Object> meta = new HashMap<>();
+        meta.put("version", version);
+        meta.put("parameters", parameters != null ? parameters.toMetadata() : Collections.emptyMap());
+        meta.put("priorities", priorities);
+        meta.put("actions", actions);
+        meta.put("fRules", fRules);
+        meta.put("gRules", gRules);
+        meta.put("stateMachine", stateMachine);
+        return meta;
+    }
+
+    public static class Parameters {
+        private Duration analysisWindow = Duration.ofMinutes(30);
+        private Duration historyWindow = Duration.ofHours(336); // 14 days
+        private Duration challengeWindow = Duration.ofMinutes(5);
+        private Duration imsiReentryWindow = Duration.ofMinutes(30);
+        private Duration imsiCooldown = Duration.ofMinutes(5);
+        private Duration imsiDwellThreshold = Duration.ofMinutes(10);
+        private Duration cameraCooldown = Duration.ofSeconds(30);
+        private Duration repeatWindow = Duration.ofHours(24);
+        private int repeatThreshold = 2;
+
+        public Duration getAnalysisWindow() {
+            return analysisWindow;
+        }
+
+        public void setAnalysisWindow(Duration analysisWindow) {
+            this.analysisWindow = analysisWindow;
+        }
+
+        public Duration getHistoryWindow() {
+            return historyWindow;
+        }
+
+        public void setHistoryWindow(Duration historyWindow) {
+            this.historyWindow = historyWindow;
+        }
+
+        public Duration getChallengeWindow() {
+            return challengeWindow;
+        }
+
+        public void setChallengeWindow(Duration challengeWindow) {
+            this.challengeWindow = challengeWindow;
+        }
+
+        public Duration getImsiReentryWindow() {
+            return imsiReentryWindow;
+        }
+
+        public void setImsiReentryWindow(Duration imsiReentryWindow) {
+            this.imsiReentryWindow = imsiReentryWindow;
+        }
+
+        public Duration getImsiCooldown() {
+            return imsiCooldown;
+        }
+
+        public void setImsiCooldown(Duration imsiCooldown) {
+            this.imsiCooldown = imsiCooldown;
+        }
+
+        public Duration getImsiDwellThreshold() {
+            return imsiDwellThreshold;
+        }
+
+        public void setImsiDwellThreshold(Duration imsiDwellThreshold) {
+            this.imsiDwellThreshold = imsiDwellThreshold;
+        }
+
+        public Duration getCameraCooldown() {
+            return cameraCooldown;
+        }
+
+        public void setCameraCooldown(Duration cameraCooldown) {
+            this.cameraCooldown = cameraCooldown;
+        }
+
+        public Duration getRepeatWindow() {
+            return repeatWindow;
+        }
+
+        public void setRepeatWindow(Duration repeatWindow) {
+            this.repeatWindow = repeatWindow;
+        }
+
+        public int getRepeatThreshold() {
+            return repeatThreshold;
+        }
+
+        public void setRepeatThreshold(int repeatThreshold) {
+            this.repeatThreshold = repeatThreshold;
+        }
+
+        public Map<String, Object> toMetadata() {
+            Map<String, Object> meta = new HashMap<>();
+            meta.put("analysisWindow", analysisWindow);
+            meta.put("historyWindow", historyWindow);
+            meta.put("challengeWindow", challengeWindow);
+            meta.put("imsiReentryWindow", imsiReentryWindow);
+            meta.put("imsiCooldown", imsiCooldown);
+            meta.put("imsiDwellThreshold", imsiDwellThreshold);
+            meta.put("cameraCooldown", cameraCooldown);
+            meta.put("repeatWindow", repeatWindow);
+            meta.put("repeatThreshold", repeatThreshold);
+            return meta;
+        }
+    }
+
+    public static class PriorityDefinition {
+        private String id;
+        private String name;
+        private String description;
+        private String guidance;
+
+        public String getId() {
+            return id;
+        }
+
+        public void setId(String id) {
+            this.id = id;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public String getDescription() {
+            return description;
+        }
+
+        public void setDescription(String description) {
+            this.description = description;
+        }
+
+        public String getGuidance() {
+            return guidance;
+        }
+
+        public void setGuidance(String guidance) {
+            this.guidance = guidance;
+        }
+    }
+
+    public static class ActionDefinition {
+        private String id;
+        private String name;
+        private String description;
+
+        public String getId() {
+            return id;
+        }
+
+        public void setId(String id) {
+            this.id = id;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public String getDescription() {
+            return description;
+        }
+
+        public void setDescription(String description) {
+            this.description = description;
+        }
+    }
+
+    public static class FRuleDefinition {
+        private String id;
+        private String name;
+        private String trigger;
+        private String dataSource;
+        private String window;
+        private String frequencyLimit;
+        private String cooldown;
+        private String actionImpact;
+
+        public String getId() {
+            return id;
+        }
+
+        public void setId(String id) {
+            this.id = id;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public String getTrigger() {
+            return trigger;
+        }
+
+        public void setTrigger(String trigger) {
+            this.trigger = trigger;
+        }
+
+        public String getDataSource() {
+            return dataSource;
+        }
+
+        public void setDataSource(String dataSource) {
+            this.dataSource = dataSource;
+        }
+
+        public String getWindow() {
+            return window;
+        }
+
+        public void setWindow(String window) {
+            this.window = window;
+        }
+
+        public String getFrequencyLimit() {
+            return frequencyLimit;
+        }
+
+        public void setFrequencyLimit(String frequencyLimit) {
+            this.frequencyLimit = frequencyLimit;
+        }
+
+        public String getCooldown() {
+            return cooldown;
+        }
+
+        public void setCooldown(String cooldown) {
+            this.cooldown = cooldown;
+        }
+
+        public String getActionImpact() {
+            return actionImpact;
+        }
+
+        public void setActionImpact(String actionImpact) {
+            this.actionImpact = actionImpact;
+        }
+    }
+
+    public static class GRuleDefinition {
+        private String id;
+        private String name;
+        private String trigger;
+        private String action;
+        private String notes;
+
+        public String getId() {
+            return id;
+        }
+
+        public void setId(String id) {
+            this.id = id;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public String getTrigger() {
+            return trigger;
+        }
+
+        public void setTrigger(String trigger) {
+            this.trigger = trigger;
+        }
+
+        public String getAction() {
+            return action;
+        }
+
+        public void setAction(String action) {
+            this.action = action;
+        }
+
+        public String getNotes() {
+            return notes;
+        }
+
+        public void setNotes(String notes) {
+            this.notes = notes;
+        }
+    }
+
+    public static class StateMachineDefinition {
+        private List<StateDefinition> states = new ArrayList<>();
+        private List<TransitionDefinition> transitions = new ArrayList<>();
+
+        public List<StateDefinition> getStates() {
+            return states;
+        }
+
+        public void setStates(List<StateDefinition> states) {
+            this.states = states != null ? new ArrayList<>(states) : new ArrayList<>();
+        }
+
+        public List<TransitionDefinition> getTransitions() {
+            return transitions;
+        }
+
+        public void setTransitions(List<TransitionDefinition> transitions) {
+            this.transitions = transitions != null ? new ArrayList<>(transitions) : new ArrayList<>();
+        }
+    }
+
+    public static class StateDefinition {
+        private String id;
+        private String name;
+        private String description;
+
+        public String getId() {
+            return id;
+        }
+
+        public void setId(String id) {
+            this.id = id;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public String getDescription() {
+            return description;
+        }
+
+        public void setDescription(String description) {
+            this.description = description;
+        }
+    }
+
+    public static class TransitionDefinition {
+        private String from;
+        private String to;
+        private String trigger;
+
+        public String getFrom() {
+            return from;
+        }
+
+        public void setFrom(String from) {
+            this.from = from;
+        }
+
+        public String getTo() {
+            return to;
+        }
+
+        public void setTo(String to) {
+            this.to = to;
+        }
+
+        public String getTrigger() {
+            return trigger;
+        }
+
+        public void setTrigger(String trigger) {
+            this.trigger = trigger;
+        }
+    }
+
+    public void validate() {
+        Objects.requireNonNull(parameters, "parameters must not be null");
+        Objects.requireNonNull(version, "version must not be null");
+        ensurePriorityIndex();
+        ensureActionIndex();
+    }
+}
+
diff --git a/backend/src/main/java/com/example/nvr/risk/config/RiskModelConfigLoader.java b/backend/src/main/java/com/example/nvr/risk/config/RiskModelConfigLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..de5f88de4e01996a7151636d6682530a6fb0ce52
--- /dev/null
+++ b/backend/src/main/java/com/example/nvr/risk/config/RiskModelConfigLoader.java
@@ -0,0 +1,48 @@
+package com.example.nvr.risk.config;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.core.io.Resource;
+import org.springframework.core.io.ResourceLoader;
+import org.springframework.stereotype.Component;
+
+import java.io.IOException;
+
+/**
+ * Loads the 风控模型 YAML once at startup.
+ */
+@Component
+public class RiskModelConfigLoader {
+
+    private static final Logger log = LoggerFactory.getLogger(RiskModelConfigLoader.class);
+
+    private final RiskModelConfig config;
+
+    public RiskModelConfigLoader(ResourceLoader resourceLoader) {
+        this.config = load(resourceLoader);
+    }
+
+    private RiskModelConfig load(ResourceLoader resourceLoader) {
+        try {
+            Resource resource = resourceLoader.getResource("classpath:risk/risk-model.yml");
+            if (!resource.exists()) {
+                throw new IllegalStateException("Missing risk model YAML at classpath:risk/risk-model.yml");
+            }
+            ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
+            mapper.findAndRegisterModules();
+            RiskModelConfig loaded = mapper.readValue(resource.getInputStream(), RiskModelConfig.class);
+            loaded.validate();
+            log.info("Loaded risk model configuration version {}", loaded.getVersion());
+            return loaded;
+        } catch (IOException ex) {
+            throw new IllegalStateException("Failed to load risk model YAML", ex);
+        }
+    }
+
+    public RiskModelConfig getConfig() {
+        return config;
+    }
+}
+
diff --git a/backend/src/main/resources/risk/risk-model.yml b/backend/src/main/resources/risk/risk-model.yml
new file mode 100644
index 0000000000000000000000000000000000000000..213d9d5e83c223c6f295a723531a854fbd478241
--- /dev/null
+++ b/backend/src/main/resources/risk/risk-model.yml
@@ -0,0 +1,126 @@
+version: "2024Q3-RC"
+parameters:
+  analysisWindow: PT30M
+  historyWindow: PT336H   # 14 days
+  challengeWindow: PT5M
+  imsiReentryWindow: PT30M
+  imsiCooldown: PT5M
+  imsiDwellThreshold: PT10M
+  cameraCooldown: PT30S
+  repeatWindow: PT24H
+  repeatThreshold: 2
+priorities:
+  - id: P1
+    name: "最高优先级"
+    description: "确认的重大入侵威胁事件，例如闯入核心保护区或多传感器同时报警。"
+    guidance: "立即执行A2远程警示与A3人力出警，并保持实时跟踪。"
+  - id: P2
+    name: "高优先级"
+    description: "严重怀疑的入侵威胁，存在持续徘徊或多次重返的迹象。"
+    guidance: "执行A2远程交互，观察挑战窗口，如无效则按G2派警。"
+  - id: P3
+    name: "中等优先级"
+    description: "一般可疑事件，需要持续监视并准备升级。"
+    guidance: "执行A1监控记录，人工评估是否需要远程警告。"
+  - id: P4
+    name: "低优先级"
+    description: "轻微异常或系统试探，仅记录并继续观察。"
+    guidance: "保持监控，等待更多证据。"
+actions:
+  - id: A1
+    name: "监控记录"
+    description: "静默关注，自动录像与事件标记，未主动干预。"
+  - id: A2
+    name: "远程交互"
+    description: "语音警告、闪灯或警号等远程劝离手段。"
+  - id: A3
+    name: "人力响应"
+    description: "派遣安保或通知警方现场处置。"
+fRules:
+  - id: F1
+    name: "一般保护区闯入"
+    trigger: "摄像头AI检测人形进入一般保护区域"
+    dataSource: "视频监控"
+    window: "即时触发，单目标30秒跟踪窗口"
+    frequencyLimit: "同一摄像头每30秒1次"
+    cooldown: "PT30S"
+    actionImpact: "触发A1，优先级至少提升至P3"
+  - id: F2
+    name: "未知IMSI出现"
+    trigger: "IMSI探针捕获非白名单设备首次出现"
+    dataSource: "IMSI探针"
+    window: "即时触发，同一IMSI5分钟去重"
+    frequencyLimit: "同一IMSI首次出现触发1次"
+    cooldown: "PT5M"
+    actionImpact: "触发A1，优先级提升至P3/P4"
+  - id: F3
+    name: "IMSI持续或重返"
+    trigger: "同一IMSI持续停留超过10分钟或30分钟内再次出现"
+    dataSource: "IMSI探针+历史记录"
+    window: "30分钟分析窗"
+    frequencyLimit: "同一事件周期触发1次"
+    cooldown: "PT30M"
+    actionImpact: "提升至P2，并建议执行A2"
+  - id: F4
+    name: "核心区域越界"
+    trigger: "人员跨越虚拟警戒线或周界传感器进入核心区"
+    dataSource: "视频警戒线/周界传感器"
+    window: "即时触发"
+    frequencyLimit: "每次越界触发1次"
+    cooldown: "PT1M"
+    actionImpact: "立即升至P1，执行A2并触发G1"
+gRules:
+  - id: G1
+    name: "P1直接派警"
+    trigger: "事件优先级达到P1"
+    action: "A3"
+    notes: "重大入侵立即通知值守与警方。"
+  - id: G2
+    name: "警告无效升级"
+    trigger: "执行A2后经过挑战窗口仍未解除威胁"
+    action: "A3"
+    notes: "挑战窗口与IMSI再识别周期保持一致（5分钟）。"
+  - id: G3
+    name: "重复侵扰巡查"
+    trigger: "24小时内同站点多次触发P2以上事件"
+    action: "A3"
+    notes: "用于应对持续试探或踩点。"
+stateMachine:
+  states:
+    - id: IDLE
+      name: "空闲"
+      description: "站点无事件。"
+    - id: MONITORING
+      name: "警戒激活"
+      description: "存在可疑事件，执行A1监控。"
+    - id: CHALLENGE
+      name: "远程挑战"
+      description: "已执行A2，等待挑战窗口结果。"
+    - id: DISPATCHED
+      name: "出警处理中"
+      description: "已触发A3，人力介入。"
+    - id: RESOLVED
+      name: "事件结束"
+      description: "威胁解除，进入冷却。"
+  transitions:
+    - from: IDLE
+      to: MONITORING
+      trigger: "任一F规则触发"
+    - from: MONITORING
+      to: CHALLENGE
+      trigger: "执行A2远程交互"
+    - from: CHALLENGE
+      to: DISPATCHED
+      trigger: "G2或G1触发派警"
+    - from: MONITORING
+      to: DISPATCHED
+      trigger: "G1触发"
+    - from: MONITORING
+      to: RESOLVED
+      trigger: "事件自然消退"
+    - from: CHALLENGE
+      to: RESOLVED
+      trigger: "挑战窗口内目标消失"
+    - from: DISPATCHED
+      to: RESOLVED
+      trigger: "出警完成"
diff --git a/frontend/src/pages/RiskModel.vue b/frontend/src/pages/RiskModel.vue
index f79d7b30f04cbba4d7e727c690512b66593b8dda..8fa6b5f76a669f99ed73c49bbf7221afce0de7b1 100644
--- a/frontend/src/pages/RiskModel.vue
+++ b/frontend/src/pages/RiskModel.vue
@@ -1,1014 +1,679 @@
 <script setup lang="ts">
 import { ref, computed, onMounted, onUnmounted } from 'vue'
 import { message } from 'ant-design-vue'
 
-type Classification = 'BLACK' | 'STRONG_ALERT' | 'GRAY' | 'WHITE' | 'LOG_ONLY'
+type Classification = 'P1' | 'P2' | 'P3' | 'P4' | 'INFO'
 type SubjectType = 'IMSI' | 'CAMERA' | 'RADAR' | string
 
 type RiskAssessment = {
   id: number
   subjectType: SubjectType
   subjectKey: string
   classification: Classification
   score: number | null
   summary: string | null
   windowStart: string | null
   windowEnd: string | null
   updatedAt: string | null
   details: Record<string, unknown> | null
 }
 
 const REFRESH_INTERVAL = 15000
 const loading = ref(false)
 const assessments = ref<RiskAssessment[]>([])
 const errorMessage = ref<string | null>(null)
 const pollingTimer = ref<number | null>(null)
 
-const classificationOrder: Classification[] = ['BLACK', 'STRONG_ALERT', 'GRAY', 'WHITE']
+const classificationOrder: Classification[] = ['P1', 'P2', 'P3', 'P4']
 const classificationMeta: Record<Classification, { label: string; tag: string; empty: string; description: string }> = {
-  BLACK: { label: '黑名单', tag: 'error', empty: '暂无黑名单事件', description: '评分 ≥70 或命中 F4/F3 夜间成伙等黑名单触发' },
-  STRONG_ALERT: { label: '强警戒', tag: 'warning', empty: '暂无强警戒目标', description: '评分 55–69，或命中 F5 夜外圈强警等强警戒条件' },
-  GRAY: { label: '灰观察', tag: 'processing', empty: '暂无灰名单目标', description: '评分 30–54，或夜间 AOI 短停 + 无手机等灰名单条件' },
-  WHITE: { label: '白名单', tag: 'success', empty: '暂无自动识别白名单', description: '满足农事白模式等条件' },
-  LOG_ONLY: { label: '仅记录', tag: 'default', empty: '暂无', description: '低风险，仅留存日志' },
+  P1: {
+    label: 'P1 最高优先级',
+    tag: 'error',
+    empty: '暂无 P1 事件',
+    description: '确认的重大入侵威胁（核心区越界或多传感器同时确认）。',
+  },
+  P2: {
+    label: 'P2 高优先级',
+    tag: 'warning',
+    empty: '暂无 P2 事件',
+    description: '严重怀疑的入侵威胁（持续停留或挑战失败）。',
+  },
+  P3: {
+    label: 'P3 中等优先级',
+    tag: 'processing',
+    empty: '暂无 P3 事件',
+    description: '一般可疑事件（外围闯入或未知设备）。',
+  },
+  P4: {
+    label: 'P4 低优先级',
+    tag: 'success',
+    empty: '暂无 P4 事件',
+    description: '轻微异常或系统试探，仅记录观察。',
+  },
+  INFO: {
+    label: '信息留存',
+    tag: 'default',
+    empty: '暂无',
+    description: '后备类别，用于兼容旧版数据。',
+  },
 }
 
 const subjectLabels: Record<string, string> = {
   IMSI: 'IMSI 设备',
   CAMERA: '摄像头',
   RADAR: '雷达目标',
 }
 
 const groupedAssessments = computed(() => {
   const base: Record<string, RiskAssessment[]> = {}
   Object.keys(classificationMeta).forEach((key) => {
     base[key] = []
   })
   for (const item of assessments.value) {
-    const key = classificationMeta[item.classification] ? item.classification : 'LOG_ONLY'
+    const key = classificationMeta[item.classification] ? item.classification : 'INFO'
     base[key].push(item)
   }
   return base
 })
 
 const groupedPages = computed(() => {
   const output: Record<string, RiskAssessment[][]> = {}
   Object.entries(groupedAssessments.value).forEach(([key, list]) => {
     const pages: RiskAssessment[][] = []
     for (let i = 0; i < list.length; i += 10) {
       pages.push(list.slice(i, i + 10))
     }
     output[key] = pages.length ? pages : [[]]
   })
   return output
 })
 
 const paginationState = ref<Record<string, number>>({})
 const currentPage = (key: string) => paginationState.value[key] ?? 0
 const currentPageData = (key: string) => {
   const pages = groupedPages.value[key] ?? [[]]
   const index = Math.min(currentPage(key), pages.length - 1)
   return pages[index] ?? []
 }
 const setPage = (key: string, page: number) => {
   paginationState.value = { ...paginationState.value, [key]: page }
 }
 
-const logAssessments = computed(() => groupedAssessments.value.LOG_ONLY ?? [])
+const logAssessments = computed(() => groupedAssessments.value.INFO ?? [])
 const boardHasData = computed(() =>
   classificationOrder.some((key) => (groupedAssessments.value[key]?.length ?? 0) > 0)
 )
 
 function toClassification(value: any): Classification {
   const text = typeof value === 'string' ? value.toUpperCase() : ''
   if (classificationMeta[text as Classification]) {
     return text as Classification
   }
-  return 'LOG_ONLY'
+  return 'INFO'
 }
 
 function normalizeAssessment(raw: any): RiskAssessment {
   const classification = toClassification(raw?.classification)
   return {
     id: Number(raw?.id ?? 0),
     subjectType: typeof raw?.subjectType === 'string' ? raw.subjectType : 'UNKNOWN',
     subjectKey: raw?.subjectKey != null ? String(raw.subjectKey) : '-',
     classification,
     score: raw?.score != null ? Number(raw.score) : null,
     summary: raw?.summary != null ? String(raw.summary) : null,
     windowStart: raw?.windowStart ?? null,
     windowEnd: raw?.windowEnd ?? null,
     updatedAt: raw?.updatedAt ?? raw?.windowEnd ?? null,
     details: raw?.details && typeof raw.details === 'object' ? (raw.details as Record<string, unknown>) : null,
   }
 }
 
 function formatTime(value: string | null | undefined): string {
   if (!value) return '—'
   const date = new Date(value)
   if (Number.isNaN(date.getTime())) return value
   return date.toLocaleString()
 }
 
-function formatScore(score: number | null | undefined): string {
-  if (typeof score === 'number' && Number.isFinite(score)) {
-    return `${score} 分`
-  }
-  return '—'
-}
-
 function subjectLabel(type: string): string {
   return subjectLabels[type] || type || '未知'
 }
 
-function extractScoreBreakdown(item: RiskAssessment): Array<{ id: string; score: number; description: string }> {
+function formatPriority(item: RiskAssessment): string {
+  const meta = classificationMeta[item.classification]
+  return meta ? meta.label : item.classification
+}
+
+function formatIsoDuration(value: any): string {
+  if (typeof value !== 'string' || !value.startsWith('P')) return ''
+  const match = value.match(/^P(?:(\d+)D)?T?(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/)
+  if (!match) return value
+  const [, d, h, m, s] = match
+  const parts: string[] = []
+  if (d) parts.push(`${Number(d)} 天`)
+  if (h) parts.push(`${Number(h)} 小时`)
+  if (m) parts.push(`${Number(m)} 分钟`)
+  if (s) parts.push(`${Number(s)} 秒`)
+  return parts.join('') || value
+}
+
+function summarizeMetrics(metrics: any): string | null {
+  if (!metrics || typeof metrics !== 'object') return null
+  if (Array.isArray(metrics.newDevices) && metrics.newDevices.length) {
+    return `新设备：${metrics.newDevices.slice(0, 3).join(', ')}${metrics.newDevices.length > 3 ? '…' : ''}`
+  }
+  if (Array.isArray(metrics.devices) && metrics.devices.length) {
+    return `涉事设备：${metrics.devices.slice(0, 3).join(', ')}${metrics.devices.length > 3 ? '…' : ''}`
+  }
+  if (typeof metrics.events === 'number') {
+    return `事件数：${metrics.events}`
+  }
+  if (typeof metrics.count === 'number') {
+    return `计数：${metrics.count}`
+  }
+  return null
+}
+
+function extractFRuleBreakdown(item: RiskAssessment): Array<{ id: string; text: string }> {
   const details: any = item.details
-  const scoreHits = Array.isArray(details?.scoreHits) ? details.scoreHits : []
-  return scoreHits
-    .map((hit: any, index: number) => ({
-      id: typeof hit?.id === 'string' && hit.id ? hit.id : `rule-${index}`,
-      score: Number(hit?.score ?? 0),
-      description: typeof hit?.description === 'string' ? hit.description : '',
-    }))
-    .filter((hit) => Number.isFinite(hit.score) && hit.score !== 0)
+  const fRules = Array.isArray(details?.fRules) ? details.fRules : []
+  return fRules
+    .filter((rule: any) => rule?.triggered)
+    .map((rule: any, index: number) => {
+      const id = typeof rule?.id === 'string' && rule.id ? rule.id : `rule-${index}`
+      const name = typeof rule?.definition?.name === 'string' && rule.definition.name ? rule.definition.name : id
+      const reason = typeof rule?.reason === 'string' && rule.reason ? rule.reason : name
+      const occurrences = Number(rule?.occurrences ?? 0)
+      const occText = occurrences > 1 ? `触发 ${occurrences} 次` : null
+      const duration = formatIsoDuration(rule?.duration)
+      const durationText = duration ? `持续 ${duration}` : null
+      const metricsText = summarizeMetrics(rule?.metrics)
+      const parts = [reason, occText, metricsText, durationText].filter(Boolean)
+      return { id, text: parts.join(' ｜ ') }
+    })
 }
 
 function extractFlags(item: RiskAssessment): Array<{ label: string; color: string }> {
   const details: any = item.details
   const flags: Array<{ label: string; color: string }> = []
-  if (Array.isArray(details?.directBlack) && details.directBlack.length) {
-    flags.push({ label: '黑触发', color: 'error' })
+  const fRules = Array.isArray(details?.fRules) ? details.fRules : []
+  const actions = Array.isArray(details?.actions) ? details.actions : []
+  const gRules = Array.isArray(details?.gRules) ? details.gRules : []
+  const has = (predicate: (entry: any) => boolean) => fRules.some(predicate)
+  const seen = new Set<string>()
+  if (gRules.some((rule: any) => rule?.triggered)) {
+    seen.add('DISPATCH')
+    flags.push({ label: '派警执行', color: 'error' })
   }
-  if (Array.isArray(details?.strongAlertRules) && details.strongAlertRules.length) {
-    flags.push({ label: '强警触发', color: 'orange' })
+  if (actions.some((action: any) => action?.id === 'A2' && action.triggered)) {
+    seen.add('A2')
+    flags.push({ label: '远程挑战', color: 'orange' })
   }
-  if (Array.isArray(details?.forcedGray) && details.forcedGray.length) {
-    flags.push({ label: '灰触发', color: 'warning' })
+  if (has((rule: any) => rule?.id === 'F4' && rule.triggered) && !seen.has('F4')) {
+    seen.add('F4')
+    flags.push({ label: '核心越界', color: 'magenta' })
   }
-  if (Array.isArray(details?.whiteRules) && details.whiteRules.length) {
-    flags.push({ label: '白名单规则', color: 'success' })
+  if (has((rule: any) => rule?.id === 'F3' && rule.triggered) && !seen.has('F3')) {
+    seen.add('F3')
+    flags.push({ label: 'IMSI 重返', color: 'volcano' })
+  }
+  if (has((rule: any) => rule?.id === 'F2' && rule.triggered) && !seen.has('F2')) {
+    seen.add('F2')
+    flags.push({ label: '未知 IMSI', color: 'geekblue' })
+  }
+  if (has((rule: any) => rule?.id === 'F1' && rule.triggered) && !seen.has('F1')) {
+    seen.add('F1')
+    flags.push({ label: '外围闯入', color: 'cyan' })
   }
   return flags
 }
 
+function extractActionSummaries(item: RiskAssessment): Array<{ id: string; text: string }> {
+  const details: any = item.details
+  const actions = Array.isArray(details?.actions) ? details.actions : []
+  return actions.map((action: any, index: number) => {
+    const id = typeof action?.id === 'string' && action.id ? action.id : `action-${index}`
+    const name = typeof action?.definition?.name === 'string' ? action.definition.name : id
+    const status = action?.triggered ? '已执行' : action?.recommended ? '建议执行' : '不执行'
+    const rationale = typeof action?.rationale === 'string' && action.rationale ? action.rationale : ''
+    const parts = [name, status, rationale].filter(Boolean)
+    return { id, text: parts.join(' ｜ ') }
+  })
+}
+
 async function fetchAssessments(showToast = false) {
   const shouldSpin = assessments.value.length === 0 && !loading.value
   if (shouldSpin) {
     loading.value = true
   }
   try {
     const resp = await fetch('/api/risk/assessments?limit=150', { cache: 'no-store' })
     if (!resp.ok) {
       throw new Error(`HTTP ${resp.status}`)
     }
     const data = await resp.json()
     if (!Array.isArray(data)) {
       throw new Error('返回格式异常')
     }
     assessments.value = data.map(normalizeAssessment)
     errorMessage.value = null
   } catch (err: any) {
     const msg = err?.message || String(err)
     errorMessage.value = msg
     if (showToast) {
       message.error(`风控评估加载失败：${msg}`)
     }
   } finally {
     if (shouldSpin) {
       loading.value = false
     }
   }
 }
 
 onMounted(() => {
   void fetchAssessments(true)
   pollingTimer.value = window.setInterval(() => {
     void fetchAssessments(false)
   }, REFRESH_INTERVAL)
 })
 
 onUnmounted(() => {
   if (pollingTimer.value !== null) {
     window.clearInterval(pollingTimer.value)
     pollingTimer.value = null
   }
 })
 
-const constraints = [
+const overviewHighlights = [
   {
-    title: 'IMSI 稀疏采样',
-    points: [
-      '同一设备命中间隔多为 5–8 min，小概率 10–12 min，极小概率 15 min。',
-      '相邻两次命中间隔 ≤15 min 视为同一会话，大于 15 min 判定为断开。',
-    ],
+    title: '统一时序',
+    detail: '挑战窗口、IMSI 再识别周期与派警规则统一，保证远程喊话与再入判定连贯。',
   },
   {
-    title: 'IMSI 归属地缺失',
-    points: [
-      '归属地字段大量缺失，不再以本地 / 外地作硬条件，仅在可判定时叠加 +2～+6 弱权重。',
-    ],
+    title: '动作解耦',
+    detail: 'A1/A2/A3 分层响应独立于等级，可按实时威胁自主组合。',
   },
   {
-    title: '摄像头能力',
-    points: [
-      '固定枪机可做进入 / 穿越 / 停留 / 路径级行为分析，不依赖器具或热源识别。',
-    ],
+    title: '规则可配置',
+    detail: 'F/G 规则、阈值与时间窗集中在 risk-model.yml，可热调优。',
   },
   {
-    title: '场域特性',
-    points: [
-      '荒野环境来人少，夜间是盗掘主窗口；踩点多在白天或黄昏且接近外围。',
-    ],
+    title: '状态闭环',
+    detail: '站点状态机覆盖监测、挑战、出警、结束全流程，避免事件被冷却遗忘。',
   },
   {
-    title: '人群背景',
-    points: [
-      '存在固定农事活动人员，需要模式化白名单而非一次性的静态名单。',
-    ],
+    title: '多源融合',
+    detail: 'IMSI、视频、雷达在事件级别融合，提升可信度并抑制误报。',
   },
 ]
 
-const timeWindowNotes = [
-  { title: '滑动窗口', detail: '30 min 与 90 min 两档并用（快速响应 + 行为沉淀）。' },
-  { title: 'IMSI 会话', detail: '相邻命中 ≤15 min 视为同一会话，会话起止为首末次命中时间。' },
-  { title: '摄像头会话', detail: '同一轨迹在 AOI 内的进入–离开视为一会话；10 min 内再次进入视为往返。' },
-]
-
-const timeSegments = [
-  { label: '白天', range: '06:00–18:59', weight: '低权重' },
-  { label: '黄昏', range: '19:00–20:59', weight: '中等权重' },
-  { label: '夜间', range: '21:00–05:59', weight: '高权重' },
-]
-
-const scoreBands = [
-  { level: '黑名单', range: '≥70', action: '直接报警' },
-  { level: '强警戒', range: '55–69', action: '快速复核 / 夜间布控' },
-  { level: '灰观察', range: '30–54', action: '标黄，进入观察队列' },
-  { level: '仅记录', range: '<30', action: '仅留存日志' },
-]
-
-const scoringCategories = [
-  {
-    key: 'A',
-    title: 'A. 时段基线',
-    note: '取其一',
-    items: [
-      { condition: '白天', score: '+0', detail: '06:00–18:59' },
-      { condition: '黄昏', score: '+10', detail: '19:00–20:59' },
-      { condition: '夜间', score: '+25', detail: '21:00–05:59，高风险窗口' },
-    ],
-  },
+const priorityCards = [
   {
-    key: 'B',
-    title: 'B. IMSI 稀疏命中强度（同一设备、同一 30 min 窗口）',
-    items: [
-      { condition: '命中 1 个 5 分钟桶', score: '+2', detail: '可能过路' },
-      { condition: '命中 2 个 5 分钟桶', score: '+8', detail: '约 10–16 min 停留' },
-      { condition: '命中 3 个 5 分钟桶', score: '+14', detail: '约 15–24 min 停留' },
-      { condition: '命中 ≥4 个 5 分钟桶', score: '+20', detail: '≥20–30 min 强停留 / 明显蹲守' },
-    ],
+    id: 'P1',
+    title: 'P1 最高优先级',
+    description: '核心区越界或多传感器确认的重大入侵，直接进入 A2 + G1→A3。',
   },
   {
-    key: 'C',
-    title: 'C. IMSI 时间结构（同一会话内）',
-    items: [
-      { condition: '会话内曾出现 >12 min 间隔', score: '+4', detail: '可能在边界徘徊 / 开关机 / 弱覆盖' },
-      { condition: '>15 min 断开后 ≤2 h 内同日再现', score: '+6', detail: '疑似踩点或试探重返' },
-    ],
+    id: 'P2',
+    title: 'P2 高优先级',
+    description: '持续停留、重返或挑战失败的高危事件，执行 A2，必要时 G2 派警。',
   },
   {
-    key: 'D',
-    title: 'D. 摄像头（AOI）行为',
-    items: [
-      { condition: '白天进入 AOI', score: '+10', detail: '进入坟包 AOI' },
-      { condition: '夜间进入 AOI', score: '+25', detail: '夜间进入为最强风险信号' },
-      { condition: '白天停留 >60 s', score: '+8', detail: '持续停留' },
-      { condition: '夜间停留 >60 s', score: '+15', detail: '夜间停留累加' },
-      { condition: '夜间停留 >180 s', score: '+10', detail: '在 >60 s 基础上叠加' },
-      { condition: '白天 10 min 内往返', score: '+6', detail: '快速进出侦察' },
-      { condition: '夜间 10 min 内往返', score: '+12', detail: '夜间往返高度可疑' },
-      { condition: '白天周界绕行 ≥2 次（30 min）', score: '+6', detail: '逼近 AOI 外缘但未穿越' },
-      { condition: '夜间周界绕行 ≥2 次（30 min）', score: '+10', detail: '夜间外围游走' },
-    ],
+    id: 'P3',
+    title: 'P3 中等优先级',
+    description: '外围闯入或未知设备出现，触发 A1 监控并持续评估。',
   },
   {
-    key: 'E',
-    title: 'E. 结伴特征（2 min 同步窗，跨传感器融合）',
-    items: [
-      {
-        condition: 'IMSI ≥2 设备 + 摄像头 ≥2 人影（夜间）',
-        score: '+15',
-        detail: '多人协同行动，夜间权重最高',
-      },
-      {
-        condition: '不同设备 7 天内 2 次结伴',
-        score: '+6',
-        detail: '同窗出现且同向离开，疑似同伙',
-      },
-    ],
+    id: 'P4',
+    title: 'P4 低优先级',
+    description: '轻微异常或试探事件，仅留痕监控。',
   },
-  {
-    key: 'F',
-    title: 'F. 跨日 / 踩点特征',
-    items: [
-      {
-        condition: '7 天内 ≥2 次白天外围出现（IMSI≥2 次 /30 min 或摄像头外围徘徊 >90 s），且未入 AOI',
-        score: '+10',
-        detail: '反复白天踩点',
-      },
-      {
-        condition: '踩点后 14 天内任意夜间 AOI 进入',
-        score: '直接黑名单',
-        detail: '无需再看分数，触发自动报警',
-      },
-    ],
-  },
-  {
-    key: 'G',
-    title: 'G. 归属地偶得（弱特征）',
-    items: [
-      { condition: '非本地 MCC/MNC（白天）', score: '+2', detail: '偶尔可得时加分' },
-      { condition: '非本地 MCC/MNC（夜间）', score: '+6', detail: '夜间出现更可疑' },
-    ],
-  },
-]
-
-const scoringNotes = [
-  '建议首版以 ≥70 黑名单、55–69 强警戒、30–54 灰观察、<30 仅记录，线上运行 2–4 周后结合现场数据校准阈值。',
-  '夜间 + T_hat ≥15 min 或 T_max ≥20 min 时，即便未入 AOI 也建议至少进入强警戒。',
-]
-
-const whiteListRules = [
-  {
-    title: '强白名单',
-    detail: '值守 / 考古 / 联勤等重点人员，绑定人、设备、时间段与区域，设定到期自动失效。',
-  },
-  {
-    title: '模式化白名单（农事白）',
-    detail:
-      '近 14 天内 ≥6 天白天（07:00–18:00）在外围被见到，且从不在夜间出现、从不进入 AOI，则进入农事白。夜间命中或任何 AOI 进入立刻降级为灰并清空白名单状态。',
-  },
-]
-
-const grayListRules = [
-  '夜间 IMSI 命中 ≥2 次 /30 min（即 B≥8）但未入 AOI。',
-  '夜间摄像头进入 AOI>60 s（即 D≥15），但单人且未往返。',
-  '7 天内出现踩点特征（F +10）。',
-  '黄昏（19:00–20:59）IMSI≥3 次 /30 min 或摄像头在 AOI 外缘绕行 ≥2 次。',
-  '任意时段 IMSI 重返（C +6）叠加摄像头外围停留 >90 s。',
 ]
 
-const blackListRules = [
-  '总评分 ≥70。',
-  '踩点（F）后 14 天内夜间进入 AOI。',
-  '夜间结伴进入 AOI（E 夜间 + D 夜间同时满足，无论停留时长）。',
-  '夜间 AOI 往返（D 夜间 +12）且 IMSI 命中 ≥2（B≥8）。',
-]
-
-const farmerWhiteNotes = [
-  '以时间与空间模式识别：连续多日白天外围活动、从不触碰 AOI、离开路径一致即可判农事白。',
-  '冲突优先级：夜间触发 > AOI 触发 > 结伴触发 > IMSI 强度。夜间 AOI 进入会立即压过农事白豁免。',
-  '视频侧采用植被 / 光影误报抑制，AOI 使用双线框（外缘预警、内缘报警）。',
-  'IMSI 去重：双卡 / eSIM 设备按同时间窗、同入点、同轨迹聚类，避免多计。',
-]
-
-const imsiStayMetrics = [
-  '会话停留下界 T_min = last_seen - first_seen。',
-  '停留估计 T_hat = max(T_min, (n_hits - 1) * 7 min)，适配 5–15 min 的采样间隔。',
-  '停留上界 T_max = T_min + 15 min，考虑到入出场可能漏采的极端情况。',
-  '夜间且 T_hat ≥15 min 或 T_max ≥20 min 时，建议直接进入强警戒。',
-]
-
-const escalationFlow = [
-  '黑名单（≥70 或命中黑触发）：自动报警 + 语音驱离（若有）+ 值守电话通知 + 证据包固化（IMSI 会话、AOI 轨迹/抓拍）。',
-  '强警戒（55–69）：弹窗 + 值守 30–120 s 内复核 + 夜间重点布控；14 天内再次触发灰/强警戒则升黑。',
-  '灰观察（30–54）：标黄 + 数据沉淀；90 天无复触发自动清退。',
-]
-
-const ruleTableColumns = [
-  { title: '规则 ID', dataIndex: 'id', key: 'id', width: 80 },
-  { title: '触发条件（简化）', dataIndex: 'trigger', key: 'trigger' },
-  { title: '分值', dataIndex: 'score', key: 'score', width: 120 },
-  { title: '直接效应', dataIndex: 'effect', key: 'effect', width: 220 },
-]
-
-const ruleTableData = [
-  { id: 'T1', trigger: '时段 = 夜间', score: '+25', effect: '—' },
-  { id: 'T2', trigger: 'IMSI 命中 2 / 3 / ≥4（30 min）', score: '+8 / +14 / +20', effect: '—' },
-  { id: 'T3', trigger: 'IMSI 会话含 >12 min 间隔', score: '+4', effect: '—' },
-  { id: 'T4', trigger: 'IMSI 重返（≤2 h）', score: '+6', effect: '—' },
-  { id: 'V1', trigger: '夜间进入 AOI', score: '+25', effect: '—' },
-  { id: 'V2', trigger: '夜间 AOI 停留 >60 s / >180 s', score: '+15 / +10', effect: '—' },
-  { id: 'V3', trigger: '夜间 AOI 10 min 内往返', score: '+12', effect: '—' },
-  { id: 'V4', trigger: '夜间周界绕行 ≥2 次（30 min）', score: '+10', effect: '—' },
-  { id: 'G1', trigger: '夜间结伴（IMSI≥2 + 摄像头≥2）', score: '+15', effect: '—' },
-  { id: 'P1', trigger: '7 天踩点（白天外围≥2 次）', score: '+10', effect: '14 天内夜间入 AOI → 黑名单' },
-  { id: 'W1', trigger: '农事白（14 天≥6 天白天外围、无夜/无 AOI）', score: '设为白', effect: '夜间或 AOI 进入即取消白' },
-]
-
-const scenarioExamples = [
+const actionCards = [
   {
-    title: '场景 A：夜间单人直奔坟包并停留 2 分钟',
-    evaluation:
-      'T1(+25) + V1(+25) + V2(+15) = 65；若 IMSI 恰好 2 次（+8）→ 73（黑）。即便缺 IMSI 也达 65（强警戒，可将阈值设 65 直接黑）。',
+    id: 'A1',
+    title: 'A1 监控记录',
+    detail: '静默录像、标记事件、增强跟踪，为后续处置积累证据。',
   },
   {
-    title: '场景 B：白天两次外围徘徊，三天后夜间入 AOI 30 s',
-    evaluation: '先触发 P1（踩点）+10，14 天内夜间入 AOI → 直接黑名单，无需再看得分。',
+    id: 'A2',
+    title: 'A2 远程交互',
+    detail: '语音警告、闪灯或警号，挑战入侵者并观察 5 分钟窗口。',
   },
   {
-    title: '场景 C：农民白天常在外围，两周 8 天命中，未夜间出现、未进 AOI',
-    evaluation: '进入农事白；若某晚 22:30 靠近 AOI 外缘，则立即降灰并持续监控。',
+    id: 'A3',
+    title: 'A3 人力响应',
+    detail: '通知安保/警方现场处置，G1/G2/G3 任一命中即触发。',
   },
 ]
 
-const implementationNotes = [
-  {
-    title: 'IMSI',
-    points: [
-      '会话断点 15 min，30 / 90 min 滑窗并行。',
-      '同窗多设备需去重，并与摄像头时间对齐（±2 min 容差）。',
-    ],
-  },
-  {
-    title: '视频',
-    points: [
-      'AOI 画双层框（外缘预警、内缘报警），启用入侵 / 区域停留 / 越线 / 徘徊算法。',
-      '做植被 / 阴影掩膜，保留轨迹与关键帧用于取证。',
-    ],
-  },
-  {
-    title: '名单与衰减',
-    points: [
-      '灰名单默认 90 天，强警戒 14 天内复触发升黑。',
-      '农事白滚动维持，任何夜间或 AOI 事件即时撤销。',
-    ],
-  },
-  {
-    title: '报送链路',
-    points: [
-      '黑事件输出证据包：IMSI 会话摘要 + 摄像头轨迹 / 截图 + 判定规则命中清单。',
-    ],
-  },
-]
-
-const classificationSteps = [
-  '若命中强白名单或临时白名单且在授权时间 / 区域内 → 白名单跳过。',
-  '若满足农事白模式则临时豁免；一旦夜间或 AOI 事件触发即撤销豁免并重新评分。',
-  '按规则累加评分（30 min 事件窗口），同时时段、IMSI、摄像头、群体、踩点及弱特征叠加。',
-  '若任一直接黑条件满足 → 黑名单报警。',
-  '否则按总分判断：≥70 黑；≥55 强警戒；≥30 灰；其余仅记录。',
-  '若得分未达 30，但命中灰名单强制条件（夜间徘徊、踩点等）也进入灰名单。',
-  '灰 / 强警戒存在衰减与升级逻辑：14 天 / 90 天窗口内复触发时升级，超时未复触发则降级或清退。',
-]
-
-const grayForceConditions = [
-  '夜间 IMSI ≥2 次 /30 min 且未入 AOI。',
-  '夜间单人 AOI 停留 >60 s，未往返。',
-  '触发昼间踩点（DAYTIME_SCOUTING）。',
-  '黄昏绕行或 IMSI ≥3 次。',
-  'IMSI 重返 + 外围停留 >90 s。',
-]
-
-const directBlackConditions = [
-  '近 14 天内曾触发昼间踩点且夜间进入 AOI。',
-  '夜间进入 AOI 且群体规模 ≥2（IMSI 或摄像头确认）。',
-  '夜间进入 AOI 且 10 min 内再次进入（往返）。',
-]
-
-const eventAlignmentColumns = [
-  { title: '名称', dataIndex: 'name', key: 'name', width: 180 },
-  { title: '定义', dataIndex: 'definition', key: 'definition' },
-  { title: '默认值/建议', dataIndex: 'defaultValue', key: 'defaultValue', width: 200 },
-  { title: '作用', dataIndex: 'purpose', key: 'purpose' },
+const fRuleColumns = [
+  { title: '规则', dataIndex: 'id', key: 'id', width: 80 },
+  { title: '触发条件', dataIndex: 'trigger', key: 'trigger' },
+  { title: '数据源', dataIndex: 'source', key: 'source', width: 160 },
+  { title: '时间窗', dataIndex: 'window', key: 'window', width: 160 },
+  { title: '频率限制', dataIndex: 'limit', key: 'limit', width: 200 },
+  { title: '冷却', dataIndex: 'cooldown', key: 'cooldown', width: 120 },
+  { title: '动作影响', dataIndex: 'impact', key: 'impact', width: 200 },
 ]
 
-const eventAlignmentRows = [
+const fRuleRows = [
   {
-    name: '事件窗口（incident_window）',
-    definition: '一次判定所覆盖的时间片',
-    defaultValue: '30 分钟滑窗（每 1 分钟平移）',
-    purpose: '对齐两传感器的“这段时间到底发生了什么”',
+    id: 'F1',
+    trigger: '摄像头检测一般保护区人形闯入',
+    source: '视频监控（虚拟警戒线/入侵）',
+    window: '即时触发，单目标追踪 30s',
+    limit: '同一摄像头 30s 内至多 1 次',
+    cooldown: '30s',
+    impact: '触发 A1，事件优先级 ≥ P3',
   },
   {
-    name: '围栏去重',
-    definition: 'Burst 合并（90s）、5 分钟分桶、15 分钟会话断点',
-    defaultValue: '90s / 5min / 15min',
-    purpose: '去除重复条，沿用既有口径',
+    id: 'F2',
+    trigger: 'IMSI 探针捕获非白名单设备首次出现',
+    source: 'IMSI 探针',
+    window: '即时触发，同一设备 5 分钟去重',
+    limit: '同一 IMEI/IMSI 首次出现 1 次',
+    cooldown: '5min',
+    impact: '触发 A1，提升至 P3/P4',
   },
   {
-    name: '紧邻同窗（tight）',
-    definition: '摄像头事件时间点 ±5 分钟内的围栏统计',
-    defaultValue: '±5 分钟',
-    purpose: '快速确认同窗是否有设备到达/聚集',
+    id: 'F3',
+    trigger: 'IMSI 持续停留 ≥10min 或 30min 内重返',
+    source: 'IMSI + 历史会话',
+    window: '30min 分析窗',
+    limit: '同一事件周期 1 次',
+    cooldown: '30min',
+    impact: '提升至 P2，建议执行 A2',
   },
   {
-    name: '宽松同窗（loose）',
-    definition: '摄像头事件时间点 ±10 分钟内的围栏统计',
-    defaultValue: '±10 分钟',
-    purpose: '纳入稍滞后/提前的到达峰值',
-  },
-  {
-    name: '到达数（arrivals_10m）',
-    definition: '近 10 分钟首次出现的唯一设备数',
-    defaultValue: '10 分钟窗口',
-    purpose: '关注“新进来的人”而非总量',
-  },
-  {
-    name: '到达异常（arrival_z）',
-    definition: '近 10 分钟到达数的 z 分数（对比历史同时段夜/昼基线）',
-    defaultValue: '阈值 z≥2',
-    purpose: '发现“今天不对劲，比平时多很多”',
-  },
-  {
-    name: '唯一桶数（bucket_count）',
-    definition: '30 分钟内有命中的 5 分钟桶数量',
-    defaultValue: '0–6',
-    purpose: '更稳健地代替“次数”，避免重复统计',
+    id: 'F4',
+    trigger: '跨越虚拟警戒线进入核心区',
+    source: '视频警戒线 / 周界传感器',
+    window: '即时触发',
+    limit: '每次越界 1 次',
+    cooldown: '1min',
+    impact: '立即升至 P1，执行 A2 并触发 G1',
   },
 ]
 
-const fusionColumns = [
-  { title: '编码', dataIndex: 'code', key: 'code', width: 120 },
-  { title: '条件（摄像头事件与围栏时序对齐）', dataIndex: 'condition', key: 'condition' },
-  { title: '白天 +分', dataIndex: 'dayScore', key: 'dayScore', width: 120 },
-  { title: '夜间 +分', dataIndex: 'nightScore', key: 'nightScore', width: 140 },
+const gRuleColumns = [
+  { title: '规则', dataIndex: 'id', key: 'id', width: 80 },
+  { title: '触发条件', dataIndex: 'trigger', key: 'trigger' },
+  { title: '动作', dataIndex: 'action', key: 'action', width: 120 },
   { title: '说明', dataIndex: 'note', key: 'note' },
 ]
 
-const fusionRows = [
-  {
-    code: 'F1 同窗协同',
-    condition: '摄像头进入 AOI，且 loose(±10m) 内 arrivals_10m ≥ 2 或 arrival_z ≥ 2',
-    dayScore: '+8',
-    nightScore: '+15',
-    note: '夜里“进点”同时有新设备涌入/明显异常 = 协同作案迹象',
-  },
-  {
-    code: 'F2 无手机嫌疑',
-    condition: '摄像头进入 AOI，且 tight(±5m) 内 arrivals_10m = 0 且站点检出率高',
-    dayScore: '+2',
-    nightScore: '+12',
-    note: '夜里进点没有任何新设备迹象 → 可能关机/留机/无手机',
-  },
+const gRuleRows = [
   {
-    code: 'F3 成伙协同',
-    condition: '摄像头画面 ≥2 人，且 tight(±5m) 内 arrivals_10m ≥ 2',
-    dayScore: '+6',
-    nightScore: '+15',
-    note: '两边都显示“多人同窗”',
+    id: 'G1',
+    trigger: '事件优先级达到 P1',
+    action: 'A3',
+    note: '重大入侵立即派警，忽略低优先级规则。',
   },
   {
-    code: 'F4 踩点→返场',
-    condition: '7 天内出现白天/傍晚外围踩线，且 14 天内夜间任意一次进入 AOI',
-    dayScore: '—',
-    nightScore: '直接黑（触发黑名单）',
-    note: '踩点→夜返，无需再看分数',
+    id: 'G2',
+    trigger: 'A2 执行后挑战窗口（5min）仍未解除',
+    action: 'A3',
+    note: '警告无效立即升级为出警。',
   },
   {
-    code: 'F5 夜外圈强警',
-    condition: '夜间未见摄像头事件，但围栏 30 分钟内 bucket_count ≥ 3 或 T_hat ≥ 15min 或 T_max ≥ 20min',
-    dayScore: '—',
-    nightScore: '强警（升级强警戒）',
-    note: '外圈蹲守，先行喝止/布控',
-  },
-  {
-    code: 'F6 夜异常汇聚',
-    condition: '夜间，loose 内 arrival_z ≥ 3，且任意摄像头外围徘徊/靠近',
-    dayScore: '+4',
-    nightScore: '+10',
-    note: '极端“车人涌入”背景下的靠近更可疑',
+    id: 'G3',
+    trigger: '24h 内同站点多次触发 P2/P1',
+    action: 'A3',
+    note: '持续试探或踩点触发巡查。',
   },
 ]
 
-const decisionColumns = [
-  { title: '等级', dataIndex: 'level', key: 'level', width: 120 },
-  { title: '触发（任意满足）', dataIndex: 'triggers', key: 'triggers' },
-  { title: '处置', dataIndex: 'actions', key: 'actions' },
+const stateMachineSteps = [
+  { state: 'IDLE', description: '空闲：站点无事件。' },
+  { state: 'MONITORING', description: '警戒激活：任一 F 规则触发，执行 A1。' },
+  { state: 'CHALLENGE', description: '远程挑战：A2 执行后等待挑战窗口。' },
+  { state: 'DISPATCHED', description: '出警处理中：G1/G2/G3 任一命中，执行 A3。' },
+  { state: 'RESOLVED', description: '事件结束：威胁解除或出警完成，进入冷却。' },
 ]
 
-const decisionRows = [
-  {
-    level: '黑名单',
-    triggers: '① 总分 ≥ 70；② F4（踩点→夜返）；③ 夜间成伙进入 AOI（摄像头≥2 人且 F3 达标）；④ 夜间往返进入 AOI（沿用原规则）',
-    actions: '立刻报警、语音驱离、通知值守、取证包',
-  },
-  {
-    level: '强警戒',
-    triggers: '① 总分 55–69；② F5（夜外圈强警）；③ F1 协同 + AOI 停留 >60s 且人数单一',
-    actions: '立即关注、喊话、近距离巡查',
-  },
-  {
-    level: '灰名单',
-    triggers: '① 总分 30–54；② 夜间单次 AOI 短停 + F2 无手机嫌疑；③ 多日晚间外围绕行 + arrival_z ≥ 2',
-    actions: '90 天观察、复触发上调',
-  },
+const advantageList = [
+  'P1–P4 多因子优先级替代旧版 E1–E3，准确反映威胁强度。',
+  'A1/A2/A3 响应解耦，远程喊话与现场派警各自可控。',
+  '派警决策由 G1–G3 接管，规则互斥且优先级清晰，避免重复出警。',
+  'F 规则标准化定义时间窗、冷却与数据源，易于工程落地。',
+  '站点状态机与事件融合引擎让 IMSI、视频、雷达形成单一事件视角。',
+  'YAML 参数集中管理，可结合现场反馈快速调优。',
 ]
 
-const scenarioColumns = [
-  { title: '场景', dataIndex: 'scenario', key: 'scenario' },
-  { title: '摄像头', dataIndex: 'camera', key: 'camera' },
-  { title: '围栏', dataIndex: 'perimeter', key: 'perimeter' },
-  { title: '结论', dataIndex: 'conclusion', key: 'conclusion' },
-]
-
-const scenarioRows = [
-  {
-    scenario: 'A 夜间单人进 AOI 停留 2 分钟，同窗无新设备',
-    camera: '进 AOI + 停留 >60s',
-    perimeter: 'arrivals_10m = 0（tight）',
-    conclusion: 'AOI(+25)+停留(+15)+F2(+12)+夜间基分(+25)=77 → 黑名单',
-  },
-  {
-    scenario: 'B 夜间两人进 AOI，同窗有 3 台新设备',
-    camera: '进 AOI + ≥2 人',
-    perimeter: 'arrivals_10m = 3（tight）',
-    conclusion: 'AOI(+25)+F3(+15)+F1(+15)+夜间(+25)=80 → 黑名单',
-  },
-  {
-    scenario: 'C 夜间未进 AOI，外圈同一设备 30 分钟≥3 桶',
-    camera: '无',
-    perimeter: 'bucket_count ≥ 3（30 分钟）',
-    conclusion: 'F5 触发 → 强警戒（喊退 + 布控）',
-  },
-  {
-    scenario: 'D 白天两次外围绕行 + 7 天内多次“到达”',
-    camera: '外围绕行 ≥2 次',
-    perimeter: 'arrival_z ≥ 2',
-    conclusion: '灰名单；若 14 天内夜进 AOI → F4 直接黑',
-  },
+const migrationSteps = [
+  '导入 risk-model.yml 并校准站点参数（警戒线、挑战窗口、冷却时间等）。',
+  '部署融合引擎与状态机模块，联调 IMSI / 摄像头 / 雷达数据接口。',
+  '分阶段启用：先监测后处置，收集触发数据再逐步开放 A2/A3。',
+  '培训值守人员理解 P1–P4 与 A1/A2/A3 的对应策略。',
+  '上线后持续评估误报/漏报情况，通过配置迭代优化规则。',
 ]
 
-const engineeringGuidelines = [
-  '只在时间同窗做加权，不做身份绑定：摄像头看到的人未必携机，允许“无手机”成为可疑信号（F2）。',
-  '分别建设摄像头与围栏基线：AOI 进入/停留/人数 vs arrivals_10m、arrival_z、bucket_count、会话重返，融合时仅用 tight/loose 同窗加权。',
-  'site_detectability_baseline 持续自校正，只有高可检出站点才启用 F2 的强加分，避免弱覆盖点误判。',
-  '多站点可选项：若围栏有扇区/多点接收，可进一步加上方向同窗的小权重；没有就跳过。',
+const fusionHighlights = [
+  'IMSI 再识别窗口与挑战窗口统一为 5 分钟，保证远程喊话结果可验证。',
+  '事件详情包含 F 规则触发次数、持续时长、涉事设备等指标，便于复核。',
+  '雷达数据可用于补强无光场景的发现能力，并在详情中展示触发计数。',
 ]
 
 </script>
 
 <template>
   <div class="risk-model">
     <header class="page-header">
       <h1>风控模型总览</h1>
-      <p>墓地盗掘防控场景的 IMSI + 枪机联合风控逻辑，覆盖评分、名单、处置与工程实现要点。</p>
+      <p>古墓户外安防场景的 P1–P4 事件优先级、A1/A2/A3 响应体系与 F/G 规则重构方案。</p>
     </header>
 
     <section class="live-section">
       <h2>实时风险态势</h2>
       <p class="section-note">基于最近 90 分钟内的 IMSI / 摄像头 / 雷达数据实时评分与名单判定。</p>
       <a-spin :spinning="loading">
         <a-alert
           v-if="errorMessage"
           type="error"
           :message="`数据获取失败：${errorMessage}`"
           show-icon
           class="mb12"
         />
         <div v-if="boardHasData" class="risk-board">
           <div
             v-for="key in classificationOrder"
             :key="key"
             :class="['risk-column', `risk-column-${key.toLowerCase()}`]"
           >
             <div class="risk-column-header">
               <a-tag :color="classificationMeta[key].tag">{{ classificationMeta[key].label }}</a-tag>
               <span class="risk-count">{{ groupedAssessments[key].length }}</span>
             </div>
             <div class="risk-column-desc">{{ classificationMeta[key].description }}</div>
             <div class="risk-column-body">
               <a-empty
                 v-if="!groupedAssessments[key].length"
                 :description="classificationMeta[key].empty"
               />
               <a-list
                 v-else
                 :data-source="currentPageData(key)"
                 :pagination="false"
                 :split="false"
               >
                 <template #renderItem="{ item }">
                   <a-list-item class="risk-list-item">
                     <div class="risk-item">
                       <div class="risk-item-header">
                         <span class="risk-item-subject">{{ subjectLabel(item.subjectType) }} · {{ item.subjectKey }}</span>
-                        <span class="risk-item-score">{{ formatScore(item.score) }}</span>
+                        <a-tag :color="classificationMeta[item.classification]?.tag" class="risk-item-priority">
+                          {{ formatPriority(item) }}
+                        </a-tag>
                       </div>
                       <div v-if="item.summary" class="risk-item-summary">{{ item.summary }}</div>
                       <div v-if="extractFlags(item).length" class="risk-item-flags">
                         <a-tag
                           v-for="flag in extractFlags(item)"
                           :key="flag.label"
                           :color="flag.color"
                         >
                           {{ flag.label }}
                         </a-tag>
                       </div>
-                      <div v-if="extractScoreBreakdown(item).length" class="risk-item-breakdown">
+                      <div v-if="extractFRuleBreakdown(item).length" class="risk-item-breakdown">
                         <ul>
-                          <li v-for="hit in extractScoreBreakdown(item)" :key="hit.id">
-                            <span class="rule-desc">{{ hit.description || hit.id }}</span>
-                            <span class="rule-score">{{ hit.score }} 分</span>
+                          <li v-for="hit in extractFRuleBreakdown(item)" :key="hit.id">
+                            <span class="rule-desc">{{ hit.text }}</span>
+                          </li>
+                        </ul>
+                      </div>
+                      <div v-if="extractActionSummaries(item).length" class="risk-item-actions">
+                        <ul>
+                          <li v-for="action in extractActionSummaries(item)" :key="action.id">
+                            <span class="rule-desc">{{ action.text }}</span>
                           </li>
                         </ul>
                       </div>
                       <div class="risk-item-footer">
                         <span>更新时间：{{ formatTime(item.updatedAt) }}</span>
                         <span>窗口：{{ formatTime(item.windowStart) }} → {{ formatTime(item.windowEnd) }}</span>
                       </div>
                     </div>
                   </a-list-item>
                 </template>
               </a-list>
               <a-pagination
                 v-if="groupedPages[key] && groupedPages[key].length > 1"
                 size="small"
                 :page-size="10"
                 :current="currentPage(key) + 1"
                 :total="groupedAssessments[key].length"
                 @change="(page) => setPage(key, page - 1)"
                 style="margin-top:8px; text-align:right;"
               />
             </div>
           </div>
         </div>
         <a-empty v-else description="暂无风险事件" />
       </a-spin>
       <a-collapse v-if="logAssessments.length" :bordered="false" class="risk-log-collapse">
         <a-collapse-panel key="logs" header="低风险事件（仅记录）">
           <a-list
             size="small"
             :data-source="logAssessments"
             :pagination="false"
             :split="false"
           >
             <template #renderItem="{ item }">
               <a-list-item class="risk-log-item">
                 <div class="risk-log-main">
                   <strong>{{ subjectLabel(item.subjectType) }} · {{ item.subjectKey }}</strong>
                   <span v-if="item.summary" class="risk-log-summary">{{ item.summary }}</span>
                 </div>
                 <div class="risk-log-time">{{ formatTime(item.updatedAt) }}</div>
               </a-list-item>
             </template>
           </a-list>
         </a-collapse-panel>
       </a-collapse>
     </section>
 
-    <section>
-      <h2>事件级融合思路</h2>
-      <div class="intro-block">
-        <p>好问题：<strong>两套传感器彼此独立、无法做“同一人”的硬绑定</strong> 时，就不要做“身份级融合”，而是做 <strong>事件级融合</strong>。</p>
-        <p>把某一段时间内、某一地点周边发生的 <strong>摄像头事件</strong> 与 <strong>围栏强度/到达峰值</strong> 做 <strong>时序对齐</strong>，用“是否同窗发生”“是否出现反常到达”“是否出现‘无手机’迹象”等 <strong>场景证据</strong> 加权。</p>
-        <p>下面给出的表格与 JSON 增量用于在原有评分/名单框架上叠加事件级融合逻辑，可按需组合到现行规则中。</p>
+    <section class="model-highlights">
+      <h2>模型重构亮点</h2>
+      <div class="card-grid repeated-block">
+        <a-card v-for="item in overviewHighlights" :key="`highlight-${item.title}`" :title="item.title">
+          <p>{{ item.detail }}</p>
+        </a-card>
       </div>
     </section>
 
     <section>
-      <h2>表 1｜时空对齐与统计口径（事件级）</h2>
-      <a-table
-        class="compact-table"
-        size="small"
-        :columns="eventAlignmentColumns"
-        :data-source="eventAlignmentRows"
-        :pagination="false"
-        row-key="name"
-      />
-    </section>
-
-    <section>
-      <h2>表 2｜融合加分项（事件级，无需身份绑定）</h2>
-      <p class="section-note">这些是新增 / 调整的“融合项”，在原来的 IMSI 强度 + 摄像头行为评分基础上叠加使用。</p>
-      <a-table
-        class="compact-table"
-        size="small"
-        :columns="fusionColumns"
-        :data-source="fusionRows"
-        :pagination="false"
-        row-key="code"
-      />
-    </section>
-
-    <section>
-      <h2>表 3｜最终判定（结合既有阈值）</h2>
-      <a-table
-        class="compact-table"
-        size="small"
-        :columns="decisionColumns"
-        :data-source="decisionRows"
-        :pagination="false"
-        row-key="level"
-      />
-    </section>
-
-    <section>
-      <h2>表 4｜典型场景矩阵</h2>
-      <a-table
-        class="compact-table"
-        size="small"
-        :columns="scenarioColumns"
-        :data-source="scenarioRows"
-        :pagination="false"
-        row-key="scenario"
-      />
-    </section>
-
-    <section>
-      <h2>工程要点（避免强行绑定“同一人”）</h2>
-      <ul class="bullet-list">
-        <li v-for="note in engineeringGuidelines" :key="note">{{ note }}</li>
-      </ul>
-    </section>
-
-    <section>
-      <p class="section-note">
-        以下保留 0.1 版的规则骨架与处置说明，可与上方事件级融合指标结合使用：在同一 30 分钟事件窗口内，先按原有分层模型打底，再叠加紧邻/宽松同窗、到达峰值与无手机等融合证据。
-      </p>
+      <h2>P1–P4 事件优先级</h2>
+      <div class="card-grid priority-grid">
+        <a-card v-for="card in priorityCards" :key="card.id" :title="card.title">
+          <p>{{ card.description }}</p>
+        </a-card>
+      </div>
     </section>
 
     <section>
-      <h2>0）现场约束 → 规则设计要点</h2>
-      <div class="card-grid repeated-block">
-        <a-card v-for="item in constraints" :key="`constraint-${item.title}`" :title="item.title">
-          <ul class="bullet-list">
-            <li v-for="point in item.points" :key="`constraint-${item.title}-${point}`">{{ point }}</li>
-          </ul>
+      <h2>A1/A2/A3 响应动作</h2>
+      <div class="card-grid action-grid">
+        <a-card v-for="card in actionCards" :key="card.id" :title="card.title">
+          <p>{{ card.detail }}</p>
         </a-card>
       </div>
     </section>
 
     <section>
-      <h2>1）事件模型与时间窗</h2>
-      <div class="card-grid repeated-block">
-        <a-card v-for="item in timeWindowNotes" :key="`tw-${item.title}`" :title="item.title">
-          <p>{{ item.detail }}</p>
-        </a-card>
-      </div>
+      <h2>F 规则标准化定义</h2>
       <a-table
         class="compact-table"
         size="small"
-        :columns="[
-          { title: '时段', dataIndex: 'label', key: 'label' },
-          { title: '时间范围', dataIndex: 'range', key: 'range' },
-          { title: '权重提示', dataIndex: 'weight', key: 'weight' },
-        ]"
-        :data-source="timeSegments"
+        :columns="fRuleColumns"
+        :data-source="fRuleRows"
         :pagination="false"
-        row-key="label"
+        row-key="(record) => record.id"
       />
     </section>
 
     <section>
-      <h2>2）稀疏友好风险评分（0–100）</h2>
+      <h2>G 规则派警决策引擎</h2>
       <a-table
         class="compact-table"
         size="small"
-        :columns="[
-          { title: '等级', dataIndex: 'level', key: 'level' },
-          { title: '分数区间', dataIndex: 'range', key: 'range' },
-          { title: '处置建议', dataIndex: 'action', key: 'action' },
-        ]"
-        :data-source="scoreBands"
+        :columns="gRuleColumns"
+        :data-source="gRuleRows"
         :pagination="false"
-        row-key="level"
+        row-key="(record) => record.id"
       />
-      <ul class="bullet-list section-note">
-        <li v-for="note in scoringNotes" :key="note">{{ note }}</li>
-      </ul>
-      <div class="card-stack repeated-block">
-        <a-card v-for="cat in scoringCategories" :key="`cat-${cat.key}`" :title="cat.title">
-          <p v-if="cat.note" class="card-note">{{ cat.note }}</p>
-          <a-table
-            size="small"
-            class="nested-table"
-            :columns="[
-              { title: '触发条件', dataIndex: 'condition', key: 'condition' },
-              { title: '分值', dataIndex: 'score', key: 'score', width: 120 },
-              { title: '说明', dataIndex: 'detail', key: 'detail' },
-            ]"
-            :data-source="cat.items"
-            :pagination="false"
-            :row-key="(record) => `${cat.key}-${record.condition}`"
-          />
-        </a-card>
-      </div>
     </section>
 
     <section>
-      <h2>3）名单规则（结合评分阈值）</h2>
-      <div class="card-grid repeated-block">
-        <a-card v-for="item in whiteListRules" :key="`wh-${item.title}`" :title="item.title">
-          <p>{{ item.detail }}</p>
-        </a-card>
-      </div>
-      <a-card title="灰名单触发条件（任一满足）" class="mt16">
-        <ul class="bullet-list">
-          <li v-for="rule in grayListRules" :key="rule">{{ rule }}</li>
-        </ul>
-      </a-card>
-      <a-card title="黑名单（直接报警）" class="mt16">
-        <ul class="bullet-list">
-          <li v-for="rule in blackListRules" :key="rule">{{ rule }}</li>
-        </ul>
-      </a-card>
+      <h2>站点状态机</h2>
+      <ol class="timeline-list">
+        <li v-for="step in stateMachineSteps" :key="step.state"><strong>{{ step.state }}</strong>：{{ step.description }}</li>
+      </ol>
     </section>
 
     <section>
-      <h2>4）“农民/熟客”与误报抑制</h2>
+      <h2>多源融合重点</h2>
       <ul class="bullet-list">
-        <li v-for="note in farmerWhiteNotes" :key="note">{{ note }}</li>
+        <li v-for="item in fusionHighlights" :key="item">{{ item }}</li>
       </ul>
     </section>
 
     <section>
-      <h2>5）稀疏 IMSI 下的停留时长估计</h2>
+      <h2>主要变化与优势</h2>
       <ul class="bullet-list">
-        <li v-for="metric in imsiStayMetrics" :key="metric">{{ metric }}</li>
+        <li v-for="item in advantageList" :key="item">{{ item }}</li>
       </ul>
     </section>
 
     <section>
-      <h2>6）处置分级与联动</h2>
-      <ul class="bullet-list">
-        <li v-for="item in escalationFlow" :key="item">{{ item }}</li>
-      </ul>
-    </section>
-
-    <section>
-      <h2>7）规则表（示例）</h2>
-      <a-table
-        class="compact-table"
-        size="small"
-        :columns="ruleTableColumns"
-        :data-source="ruleTableData"
-        :pagination="false"
-        row-key="id"
-      />
-    </section>
-
-    <section>
-      <h2>8）典型场景判定示例</h2>
-      <div class="card-stack repeated-block">
-        <a-card v-for="scene in scenarioExamples" :key="`scene-${scene.title}`" :title="scene.title">
-          <p>{{ scene.evaluation }}</p>
-        </a-card>
-      </div>
-    </section>
-
-    <section>
-      <h2>9）实施要点（工程配置）</h2>
-      <div class="card-stack repeated-block">
-        <a-card v-for="block in implementationNotes" :key="`impl-${block.title}`" :title="block.title">
-          <ul class="bullet-list">
-            <li v-for="point in block.points" :key="`impl-${block.title}-${point}`">{{ point }}</li>
-          </ul>
-        </a-card>
-      </div>
-    </section>
-
-    <section>
-      <h2>判定与升级逻辑梳理</h2>
-      <a-card title="分类步骤">
-        <ul class="bullet-list">
-          <li v-for="step in classificationSteps" :key="step">{{ step }}</li>
-        </ul>
-      </a-card>
-      <div class="card-grid mt16">
-        <a-card title="灰名单强制条件">
-          <ul class="bullet-list">
-            <li v-for="cond in grayForceConditions" :key="cond">{{ cond }}</li>
-          </ul>
-        </a-card>
-        <a-card title="直接黑名单条件">
-          <ul class="bullet-list">
-            <li v-for="cond in directBlackConditions" :key="cond">{{ cond }}</li>
-          </ul>
-        </a-card>
-      </div>
+      <h2>迁移实施建议</h2>
+      <ol class="timeline-list">
+        <li v-for="step in migrationSteps" :key="step">{{ step }}</li>
+      </ol>
     </section>
 
   </div>
 </template>
 
 
 <style scoped>
 .fusion-grid {
   display: grid;
   grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
   gap: 16px;
 }
 
 .repeated-block {
   margin-top: 16px;
 }
 
 .risk-model {
   padding: 24px;
   color: var(--text-color);
   background: rgba(12, 24, 36, 0.6);
   min-height: 100%;
   box-sizing: border-box;
 }
 
@@ -1091,66 +756,52 @@ section {
   font-weight: 600;
 }
 
 .risk-list-item {
   border: none;
 }
 
 .risk-item {
   display: grid;
   gap: 8px;
 }
 
 .risk-item-header {
   display: flex;
   align-items: flex-start;
   justify-content: space-between;
   gap: 12px;
 }
 
 .risk-item-subject {
   font-weight: 600;
   color: var(--text-color);
   word-break: break-word;
 }
 
-.risk-item-score {
+.risk-item-priority {
   font-weight: 600;
-  font-size: 20px;
-  color: #ff7875;
-}
-
-.risk-column-strong_alert .risk-item-score {
-  color: #fadb14;
-}
-
-.risk-column-gray .risk-item-score {
-  color: #69c0ff;
-}
-
-.risk-column-white .risk-item-score {
-  color: #73d13d;
 }
 
 .risk-item-summary {
   color: rgba(255, 255, 255, 0.8);
 }
 
 .risk-item-flags {
   display: flex;
   flex-wrap: wrap;
   gap: 6px;
 }
 
 .risk-item-footer {
   display: grid;
   gap: 4px;
   font-size: 12px;
   color: rgba(255, 255, 255, 0.55);
 }
 
 .risk-log-collapse {
   margin-top: 16px;
 }
 
 .risk-log-item {
   display: flex;
@@ -1191,64 +842,88 @@ h2 {
 
 .card-grid {
   display: grid;
   grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
   gap: 16px;
 }
 
 
 .risk-item-breakdown {
   padding: 8px 10px;
   background: rgba(0, 0, 0, 0.28);
   border-radius: 6px;
   display: grid;
   gap: 6px;
 }
 
 .risk-item-breakdown ul {
   list-style: none;
   padding: 0;
   margin: 0;
   display: grid;
   gap: 4px;
 }
 
 .risk-item-breakdown li {
-  display: flex;
-  justify-content: space-between;
   font-size: 12px;
-  color: rgba(255, 255, 255, 0.8);
+  color: rgba(255, 255, 255, 0.85);
 }
 
-.risk-item-breakdown .rule-desc {
-  flex: 1;
-  padding-right: 8px;
+.risk-item-breakdown .rule-desc,
+.risk-item-actions .rule-desc {
+  display: block;
 }
 
-.risk-item-breakdown .rule-score {
-  font-weight: 600;
-  color: #ffd666;
+.risk-item-actions {
+  padding: 8px 10px;
+  background: rgba(0, 0, 0, 0.18);
+  border-radius: 6px;
+}
+
+.risk-item-actions ul {
+  list-style: none;
+  padding: 0;
+  margin: 0;
+  display: grid;
+  gap: 4px;
+}
+
+.risk-item-actions li {
+  font-size: 12px;
+  color: rgba(255, 255, 255, 0.75);
+}
+
+.priority-grid .ant-card,
+.action-grid .ant-card {
+  background: rgba(0, 0, 0, 0.25);
+}
+
+.timeline-list {
+  padding-left: 18px;
+  display: grid;
+  gap: 8px;
+  color: rgba(255, 255, 255, 0.85);
 }
 
 .card-stack {
   display: grid;
   gap: 16px;
 }
 
 .intro-block {
   padding: 16px;
   border: 1px solid rgba(255, 255, 255, 0.12);
   border-radius: 8px;
   background: rgba(0, 0, 0, 0.25);
   display: grid;
   gap: 12px;
   color: rgba(255, 255, 255, 0.85);
 }
 
 .intro-block p {
   margin: 0;
 }
 
 .bullet-list {
   padding-left: 18px;
   margin: 0;
   display: grid;
